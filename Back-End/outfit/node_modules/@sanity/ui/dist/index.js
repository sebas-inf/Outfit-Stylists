"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var _visualEditing = require("./_chunks-cjs/_visual-editing.js"), jsxRuntime = require("react/jsx-runtime"), icons = require("@sanity/icons"), react = require("react"), styledComponents = require("styled-components"), reactCompilerRuntime = require("react-compiler-runtime"), theme = require("@sanity/ui/theme"), getTheme_v2 = require("./_chunks-cjs/getTheme_v2.js"), framerMotion = require("framer-motion");
function _getElements(element, elementsArg) {
  const ret = [element];
  for (const el of elementsArg)
    Array.isArray(el) ? ret.push(...el) : ret.push(el);
  return ret.filter(Boolean);
}
function useClickOutside(listener, elementsArg = _visualEditing.EMPTY_ARRAY, boundaryElement) {
  const [element, setElement] = react.useState(null), [elements, setElements] = react.useState(() => _getElements(element, elementsArg)), elementsRef = react.useRef(elements);
  return react.useEffect(() => {
    const prevElements = elementsRef.current, nextElements = _getElements(element, elementsArg);
    if (prevElements.length !== nextElements.length) {
      setElements(nextElements), elementsRef.current = nextElements;
      return;
    }
    for (const el of prevElements)
      if (!nextElements.includes(el)) {
        setElements(nextElements), elementsRef.current = nextElements;
        return;
      }
    for (const el_0 of nextElements)
      if (!prevElements.includes(el_0)) {
        setElements(nextElements), elementsRef.current = nextElements;
        return;
      }
  }, [element, elementsArg]), react.useEffect(() => {
    if (!listener) return;
    const handleWindowMouseDown = (evt) => {
      const target = evt.target;
      if (target instanceof Node && !(boundaryElement && !boundaryElement.contains(target))) {
        for (const el_1 of elements)
          if (target === el_1 || el_1.contains(target))
            return;
        listener(evt);
      }
    };
    return window.addEventListener("mousedown", handleWindowMouseDown), () => {
      window.removeEventListener("mousedown", handleWindowMouseDown);
    };
  }, [boundaryElement, listener, elements]), setElement;
}
function useElementRect(element) {
  return _visualEditing.useElementSize(element)?._contentRect || null;
}
function useForwardedRef(ref) {
  const $ = reactCompilerRuntime.c(1), innerRef = react.useRef(null);
  let t0;
  return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => innerRef.current, $[0] = t0) : t0 = $[0], react.useImperativeHandle(ref, t0), innerRef;
}
class ErrorBoundary extends react.Component {
  state = {
    error: null
  };
  static getDerivedStateFromError(error) {
    return {
      error
    };
  }
  componentDidCatch(error, info) {
    this.props.onCatch({
      error,
      info
    });
  }
  render() {
    const {
      error
    } = this.state;
    if (error) {
      const message = typeof error?.message == "string" ? error.message : "Error";
      return /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Code, { children: message });
    }
    return this.props.children;
  }
}
function _raf(fn) {
  const frameId = requestAnimationFrame(fn);
  return () => {
    cancelAnimationFrame(frameId);
  };
}
function _raf2(fn) {
  let innerDispose = null;
  const outerDispose = _raf(() => {
    innerDispose = _raf(fn);
  });
  return () => {
    innerDispose && innerDispose(), outerDispose();
  };
}
function _hasFocus(element) {
  return !!document.activeElement && element.contains(document.activeElement);
}
function isFocusable(element) {
  return element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute("tabIndex") !== null ? !0 : _visualEditing.isHTMLAnchorElement(element) ? !!element.href && element.rel !== "ignore" : _visualEditing.isHTMLInputElement(element) ? element.type !== "hidden" && element.type !== "file" && !element.disabled : _visualEditing.isHTMLButtonElement(element) || _visualEditing.isHTMLSelectElement(element) || _visualEditing.isHTMLTextAreaElement(element) ? !element.disabled : !1;
}
function attemptFocus(element) {
  if (!isFocusable(element))
    return !1;
  try {
    element.focus();
  } catch {
  }
  return document.activeElement === element;
}
function focusFirstDescendant(element) {
  for (let i = 0; i < element.childNodes.length; i++) {
    const child = element.childNodes[i];
    if (_visualEditing.isHTMLElement(child) && (attemptFocus(child) || focusFirstDescendant(child)))
      return !0;
  }
  return !1;
}
function focusLastDescendant(element) {
  for (let i = element.childNodes.length - 1; i >= 0; i--) {
    const child = element.childNodes[i];
    if (_visualEditing.isHTMLElement(child) && (attemptFocus(child) || focusLastDescendant(child)))
      return !0;
  }
  return !1;
}
const StyledAutocomplete = styledComponents.styled.div.withConfig({
  displayName: "StyledAutocomplete",
  componentId: "sc-1igauft-0"
})`line-height:0;`, ListBox = styledComponents.styled(_visualEditing.Box).withConfig({
  displayName: "ListBox",
  componentId: "sc-1igauft-1"
})`& > ul{list-style:none;padding:0;margin:0;}`, rotate = styledComponents.keyframes`
  from {
    transform: rotate(0deg);
  }

  to {
    transform: rotate(360deg);
  }
`, AnimatedSpinnerIcon = styledComponents.styled(icons.SpinnerIcon).withConfig({
  displayName: "AnimatedSpinnerIcon",
  componentId: "sc-1igauft-2"
})`animation:${rotate} 500ms linear infinite;`;
function AutocompleteOption(props) {
  const $ = reactCompilerRuntime.c(11), {
    children,
    id,
    onSelect,
    selected,
    value
  } = props;
  let t0;
  $[0] !== onSelect || $[1] !== value ? (t0 = () => {
    setTimeout(() => {
      onSelect(value);
    }, 0);
  }, $[0] = onSelect, $[1] = value, $[2] = t0) : t0 = $[2];
  const handleClick = t0;
  let t1;
  $[3] !== handleClick ? (t1 = (event) => {
    event.key === "Enter" && !_visualEditing._isEnterToClickElement(event.currentTarget) && handleClick();
  }, $[3] = handleClick, $[4] = t1) : t1 = $[4];
  const handleKeyDown = t1;
  let t2;
  return $[5] !== children || $[6] !== handleClick || $[7] !== handleKeyDown || $[8] !== id || $[9] !== selected ? (t2 = /* @__PURE__ */ jsxRuntime.jsx("li", { "aria-selected": selected, "data-ui": "AutocompleteOption", id, role: "option", onClick: handleClick, onKeyDown: handleKeyDown, children }), $[5] = children, $[6] = handleClick, $[7] = handleKeyDown, $[8] = id, $[9] = selected, $[10] = t2) : t2 = $[10], t2;
}
function autocompleteReducer(state, msg) {
  return msg.type === "input/change" ? {
    ...state,
    activeValue: null,
    focused: !0,
    query: msg.query
  } : msg.type === "input/focus" ? {
    ...state,
    focused: !0
  } : msg.type === "root/blur" ? {
    ...state,
    focused: !1,
    query: null
  } : msg.type === "root/clear" ? {
    ...state,
    activeValue: null,
    query: null,
    value: null
  } : msg.type === "root/escape" ? {
    ...state,
    focused: !1,
    query: null
  } : msg.type === "root/open" ? {
    ...state,
    query: state.query || msg.query
  } : msg.type === "root/setActiveValue" ? {
    ...state,
    activeValue: msg.value,
    listFocused: msg.listFocused || state.listFocused
  } : msg.type === "root/setListFocused" ? {
    ...state,
    listFocused: msg.listFocused
  } : msg.type === "value/change" ? {
    ...state,
    activeValue: msg.value,
    query: null,
    value: msg.value
  } : state;
}
const AUTOCOMPLETE_LISTBOX_IGNORE_KEYS = ["Control", "Shift", "Alt", "Enter", "Home", "End", "PageUp", "PageDown", "Meta", "Tab", "CapsLock"], AUTOCOMPLETE_POPOVER_PLACEMENT = "bottom-start", AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS = ["bottom-start", "top-start"], DEFAULT_RENDER_VALUE = (value, option) => option ? option.value : value, DEFAULT_FILTER_OPTION = (query, option) => option.value.toLowerCase().indexOf(query.toLowerCase()) > -1, InnerAutocomplete = react.forwardRef(function(props, forwardedRef) {
  const {
    border = !0,
    customValidity,
    disabled,
    filterOption: filterOptionProp,
    fontSize = 2,
    icon,
    id,
    listBox = _visualEditing.EMPTY_RECORD,
    loading,
    onBlur,
    onChange,
    onFocus,
    onQueryChange,
    onSelect,
    openButton,
    openOnFocus,
    options: optionsProp,
    padding: paddingProp = 3,
    popover = _visualEditing.EMPTY_RECORD,
    prefix,
    radius = 2,
    readOnly,
    relatedElements,
    renderOption: renderOptionProp,
    renderPopover,
    renderValue = DEFAULT_RENDER_VALUE,
    suffix,
    value: valueProp,
    ...restProps
  } = props, [state, dispatch] = react.useReducer(autocompleteReducer, {
    activeValue: valueProp || null,
    focused: !1,
    listFocused: !1,
    query: null,
    value: valueProp || null
  }), {
    activeValue,
    focused,
    listFocused,
    query,
    value
  } = state, defaultRenderOption = react.useCallback(({
    value: value_0
  }) => /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Card, { "data-as": "button", padding: paddingProp, radius: 2, tone: "inherit", children: /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Text, { size: fontSize, textOverflow: "ellipsis", children: value_0 }) }), [fontSize, paddingProp]), renderOption = typeof renderOptionProp == "function" ? renderOptionProp : defaultRenderOption, filterOption = typeof filterOptionProp == "function" ? filterOptionProp : DEFAULT_FILTER_OPTION, rootElementRef = react.useRef(null), resultsPopoverElementRef = react.useRef(null), inputElementRef = react.useRef(null), listBoxElementRef = react.useRef(null), listFocusedRef = react.useRef(!1), valueRef = react.useRef(value), valuePropRef = react.useRef(valueProp), popoverMouseWithinRef = react.useRef(!1);
  react.useImperativeHandle(forwardedRef, () => inputElementRef.current);
  const listBoxId = `${id}-listbox`, options = Array.isArray(optionsProp) ? optionsProp : _visualEditing.EMPTY_ARRAY, padding = _visualEditing.useArrayProp(paddingProp), currentOption = react.useMemo(() => value !== null ? options.find((o) => o.value === value) : void 0, [options, value]), filteredOptions = react.useMemo(() => options.filter((option) => query ? filterOption(query, option) : !0), [filterOption, options, query]), filteredOptionsLen = filteredOptions.length, activeItemId = activeValue ? `${id}-option-${activeValue}` : void 0, expanded = query !== null && loading || focused && query !== null, handleRootBlur = react.useCallback((event) => {
    setTimeout(() => {
      if (popoverMouseWithinRef.current)
        return;
      const elements = (relatedElements || []).concat(rootElementRef.current ? [rootElementRef.current] : [], resultsPopoverElementRef.current ? [resultsPopoverElementRef.current] : []);
      let focusInside = !1;
      if (document.activeElement) {
        for (const e of elements)
          if (e === document.activeElement || e.contains(document.activeElement)) {
            focusInside = !0;
            break;
          }
      }
      focusInside === !1 && (dispatch({
        type: "root/blur"
      }), popoverMouseWithinRef.current = !1, onQueryChange && onQueryChange(null), onBlur && onBlur(event));
    }, 0);
  }, [onBlur, onQueryChange, relatedElements]), handleRootFocus = react.useCallback((event_0) => {
    const listBoxElement = listBoxElementRef.current, focusedElement = event_0.target instanceof HTMLElement ? event_0.target : null, listFocused_0 = listBoxElement?.contains(focusedElement) || !1;
    listFocused_0 !== listFocusedRef.current && (listFocusedRef.current = listFocused_0, dispatch({
      type: "root/setListFocused",
      listFocused: listFocused_0
    }));
  }, []), handleOptionSelect = react.useCallback((v) => {
    dispatch({
      type: "value/change",
      value: v
    }), popoverMouseWithinRef.current = !1, onSelect && onSelect(v), valueRef.current = v, onChange && onChange(v), onQueryChange && onQueryChange(null), inputElementRef.current?.focus();
  }, [onChange, onSelect, onQueryChange]), handleRootKeyDown = react.useCallback((event_1) => {
    if (event_1.key === "ArrowDown") {
      if (event_1.preventDefault(), !filteredOptionsLen) return;
      const activeOption = filteredOptions.find((o_0) => o_0.value === activeValue), activeIndex = activeOption ? filteredOptions.indexOf(activeOption) : -1, nextActiveOption = filteredOptions[(activeIndex + 1) % filteredOptionsLen];
      nextActiveOption && dispatch({
        type: "root/setActiveValue",
        value: nextActiveOption.value,
        listFocused: !0
      });
      return;
    }
    if (event_1.key === "ArrowUp") {
      if (event_1.preventDefault(), !filteredOptionsLen) return;
      const activeOption_0 = filteredOptions.find((o_1) => o_1.value === activeValue), activeIndex_0 = activeOption_0 ? filteredOptions.indexOf(activeOption_0) : -1, nextActiveOption_0 = filteredOptions[activeIndex_0 === -1 ? filteredOptionsLen - 1 : (filteredOptionsLen + activeIndex_0 - 1) % filteredOptionsLen];
      nextActiveOption_0 && dispatch({
        type: "root/setActiveValue",
        value: nextActiveOption_0.value,
        listFocused: !0
      });
      return;
    }
    if (event_1.key === "Escape") {
      dispatch({
        type: "root/escape"
      }), popoverMouseWithinRef.current = !1, onQueryChange && onQueryChange(null), inputElementRef.current?.focus();
      return;
    }
    const target = event_1.target, listEl = listBoxElementRef.current;
    if ((listEl === target || listEl?.contains(target)) && !AUTOCOMPLETE_LISTBOX_IGNORE_KEYS.includes(event_1.key)) {
      inputElementRef.current?.focus();
      return;
    }
  }, [activeValue, filteredOptions, filteredOptionsLen, onQueryChange]), handleInputChange = react.useCallback((event_2) => {
    const nextQuery = event_2.currentTarget.value;
    dispatch({
      type: "input/change",
      query: nextQuery
    }), onQueryChange && onQueryChange(nextQuery);
  }, [onQueryChange]), dispatchOpen = react.useCallback(() => {
    dispatch({
      type: "root/open",
      query: value ? renderValue(value, currentOption) : ""
    });
  }, [currentOption, renderValue, value]), handleInputFocus = react.useCallback((event_3) => {
    focused || (dispatch({
      type: "input/focus"
    }), onFocus && onFocus(event_3), openOnFocus && dispatchOpen());
  }, [focused, onFocus, openOnFocus, dispatchOpen]), handlePopoverMouseEnter = react.useCallback(() => {
    popoverMouseWithinRef.current = !0;
  }, []), handlePopoverMouseLeave = react.useCallback(() => {
    popoverMouseWithinRef.current = !1;
  }, []), handleClearButtonClick = react.useCallback(() => {
    dispatch({
      type: "root/clear"
    }), valueRef.current = "", onChange && onChange(""), onQueryChange && onQueryChange(null), inputElementRef.current?.focus();
  }, [onChange, onQueryChange]), handleClearButtonFocus = react.useCallback(() => {
    dispatch({
      type: "input/focus"
    });
  }, []);
  react.useEffect(() => {
    if (valueProp !== valuePropRef.current) {
      valuePropRef.current = valueProp, valueProp !== void 0 && (dispatch({
        type: "value/change",
        value: valueProp
      }), valueRef.current = valueProp);
      return;
    }
    valueProp !== valueRef.current && (valueRef.current = valueProp || null, dispatch({
      type: "value/change",
      value: valueProp || null
    }));
  }, [valueProp]), react.useEffect(() => {
    !focused && valueRef.current && dispatch({
      type: "root/setActiveValue",
      value: valueRef.current
    });
  }, [focused]), react.useEffect(() => {
    const listElement = listBoxElementRef.current;
    if (!listElement) return;
    const activeOption_1 = filteredOptions.find((o_2) => o_2.value === activeValue);
    if (activeOption_1) {
      const activeIndex_1 = filteredOptions.indexOf(activeOption_1), activeItemElement = listElement.childNodes[activeIndex_1];
      if (activeItemElement) {
        if (_hasFocus(activeItemElement))
          return;
        focusFirstDescendant(activeItemElement);
      }
    }
  }, [activeValue, filteredOptions]);
  const clearButton = react.useMemo(() => {
    if (!loading && !disabled && value)
      return {
        "aria-label": "Clear",
        onFocus: handleClearButtonFocus
      };
  }, [disabled, handleClearButtonFocus, loading, value]), openButtonBoxPadding = react.useMemo(() => padding.map((v_0) => v_0 === 0 ? 0 : v_0 === 1 || v_0 === 2 ? 1 : v_0 - 2), [padding]), openButtonPadding = react.useMemo(() => padding.map((v_1) => Math.max(v_1 - 1, 0)), [padding]), openButtonProps = react.useMemo(() => typeof openButton == "object" ? openButton : _visualEditing.EMPTY_RECORD, [openButton]), handleOpenClick = react.useCallback((event_4) => {
    dispatchOpen(), openButtonProps.onClick && openButtonProps.onClick(event_4), _raf(() => inputElementRef.current?.focus());
  }, [openButtonProps, dispatchOpen]), openButtonNode = react.useMemo(() => !disabled && !readOnly && openButton ? /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Box, { "aria-hidden": expanded, padding: openButtonBoxPadding, children: /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Button, { "aria-label": "Open", disabled: expanded, fontSize, icon: icons.ChevronDownIcon, mode: "bleed", padding: openButtonPadding, ...openButtonProps, onClick: handleOpenClick }) }) : void 0, [disabled, expanded, fontSize, handleOpenClick, openButton, openButtonBoxPadding, openButtonPadding, openButtonProps, readOnly]), inputValue = react.useMemo(() => query === null ? value !== null ? renderValue(value, currentOption) : "" : query, [currentOption, query, renderValue, value]), input = /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.TextInput, { ...restProps, "aria-activedescendant": activeItemId, "aria-autocomplete": "list", "aria-expanded": expanded, "aria-owns": listBoxId, autoCapitalize: "off", autoComplete: "off", autoCorrect: "off", border, clearButton, customValidity, disabled, fontSize, icon, iconRight: loading && AnimatedSpinnerIcon, id, inputMode: "search", onChange: handleInputChange, onClear: handleClearButtonClick, onFocus: handleInputFocus, padding, prefix, radius, readOnly, ref: inputElementRef, role: "combobox", spellCheck: !1, suffix: suffix || openButtonNode, value: inputValue }), handleListBoxKeyDown = react.useCallback((event_5) => {
    event_5.key === "Tab" && listFocused && inputElementRef.current?.focus();
  }, [listFocused]), content = react.useMemo(() => filteredOptions.length === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(ListBox, { "data-ui": "AutoComplete__results", onKeyDown: handleListBoxKeyDown, padding: 1, ...listBox, tabIndex: -1, children: /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Stack, { as: "ul", "aria-multiselectable": !1, "data-ui": "AutoComplete__resultsList", id: listBoxId, ref: listBoxElementRef, role: "listbox", space: 1, children: filteredOptions.map((option_0) => {
    const active = activeValue !== null ? option_0.value === activeValue : currentOption === option_0;
    return /* @__PURE__ */ jsxRuntime.jsx(AutocompleteOption, { id: `${id}-option-${option_0.value}`, onSelect: handleOptionSelect, selected: active, value: option_0.value, children: react.cloneElement(renderOption(option_0), {
      disabled: loading,
      selected: active,
      tabIndex: listFocused && active ? 0 : -1
    }) }, option_0.value);
  }) }) }), [activeValue, currentOption, filteredOptions, handleOptionSelect, handleListBoxKeyDown, id, listBox, listBoxId, listFocused, loading, renderOption]), results = react.useMemo(() => renderPopover ? renderPopover({
    content,
    hidden: !expanded,
    inputElement: inputElementRef.current,
    onMouseEnter: handlePopoverMouseEnter,
    onMouseLeave: handlePopoverMouseLeave
  }, resultsPopoverElementRef) : filteredOptionsLen === 0 ? null : /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Popover, { arrow: !1, constrainSize: !0, content, fallbackPlacements: AUTOCOMPLETE_POPOVER_FALLBACK_PLACEMENTS, matchReferenceWidth: !0, onMouseEnter: handlePopoverMouseEnter, onMouseLeave: handlePopoverMouseLeave, open: expanded, overflow: "auto", placement: AUTOCOMPLETE_POPOVER_PLACEMENT, portal: !0, radius, ref: resultsPopoverElementRef, referenceElement: inputElementRef.current, ...popover }), [content, expanded, filteredOptionsLen, handlePopoverMouseEnter, handlePopoverMouseLeave, popover, radius, renderPopover]);
  return /* @__PURE__ */ jsxRuntime.jsxs(StyledAutocomplete, { "data-ui": "Autocomplete", onBlur: handleRootBlur, onFocus: handleRootFocus, onKeyDown: handleRootKeyDown, ref: rootElementRef, children: [
    input,
    results
  ] });
});
InnerAutocomplete.displayName = "ForwardRef(Autocomplete)";
const Autocomplete = InnerAutocomplete, StyledBreadcrumbs = styledComponents.styled.ol.withConfig({
  displayName: "StyledBreadcrumbs",
  componentId: "sc-1es8h8q-0"
})`margin:0;padding:0;display:flex;list-style:none;align-items:center;white-space:nowrap;line-height:0;`, ExpandButton = styledComponents.styled(_visualEditing.Button).withConfig({
  displayName: "ExpandButton",
  componentId: "sc-1es8h8q-1"
})`appearance:none;margin:-4px;`, Breadcrumbs = react.forwardRef(function(props, ref) {
  const {
    children,
    maxLength,
    separator,
    space: spaceRaw = 2,
    ...restProps
  } = props, space = _visualEditing.useArrayProp(spaceRaw), [open, setOpen] = react.useState(!1), expandElementRef = react.useRef(null), popoverElementRef = react.useRef(null), collapse = react.useCallback(() => setOpen(!1), []), expand = react.useCallback(() => setOpen(!0), []);
  _visualEditing.useClickOutsideEvent(collapse, () => [expandElementRef.current, popoverElementRef.current]);
  const rawItems = react.useMemo(() => react.Children.toArray(children).filter(react.isValidElement), [children]), items = react.useMemo(() => {
    const len = rawItems.length;
    if (maxLength && len > maxLength) {
      const beforeLength = Math.ceil(maxLength / 2), afterLength = Math.floor(maxLength / 2);
      return [...rawItems.slice(0, beforeLength - 1), /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Popover, { constrainSize: !0, content: /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Stack, { as: "ol", overflow: "auto", padding: space, space, children: rawItems.slice(beforeLength - 1, len - afterLength) }), open, placement: "top", portal: !0, ref: popoverElementRef, children: /* @__PURE__ */ jsxRuntime.jsx(ExpandButton, { fontSize: 1, mode: "bleed", onClick: open ? collapse : expand, padding: 1, ref: expandElementRef, selected: open, text: "\u2026" }) }, "button"), ...rawItems.slice(len - afterLength)];
    }
    return rawItems;
  }, [collapse, expand, maxLength, open, rawItems, space]);
  return /* @__PURE__ */ jsxRuntime.jsx(StyledBreadcrumbs, { "data-ui": "Breadcrumbs", ...restProps, ref, children: items.map((item, itemIndex) => /* @__PURE__ */ jsxRuntime.jsxs(react.Fragment, { children: [
    itemIndex > 0 && /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Box, { "aria-hidden": !0, as: "li", paddingX: space, children: separator || /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Text, { muted: !0, children: "/" }) }),
    /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Box, { as: "li", children: item })
  ] }, itemIndex)) });
});
Breadcrumbs.displayName = "ForwardRef(Breadcrumbs)";
function dialogStyle({
  theme: theme$1
}) {
  const {
    color
  } = theme.getTheme_v2(theme$1);
  return {
    "&:not([hidden])": {
      display: "flex"
    },
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    alignItems: "center",
    justifyContent: "center",
    outline: "none",
    background: color.backdrop
  };
}
function responsiveDialogPositionStyle(props) {
  const {
    media
  } = theme.getTheme_v2(props.theme);
  return _visualEditing._responsive(media, props.$position, (position) => ({
    "&&": {
      position
    }
  }));
}
function animationDialogStyle(props) {
  return props.$animate ? styledComponents.css`
    @keyframes zoomIn {
      from {
        opacity: 0;
        transform: scale(0.95);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }
    @keyframes fadeIn {
      from {
        opacity: 0;
      }
      to {
        opacity: 1;
      }
    }

    animation: fadeIn 200ms ease-out;
    // Animates the dialog card.
    & > [data-ui='DialogCard'] {
      animation: zoomIn 200ms ease-out;
    }
  ` : styledComponents.css``;
}
const DialogContext = _visualEditing.createGlobalScopedContext("@sanity/ui/context/dialog", {
  version: 0
});
function useDialog() {
  return react.useContext(DialogContext);
}
function isTargetWithinScope(boundaryElement, portalElement, target) {
  return !boundaryElement || !portalElement ? !0 : _visualEditing.containsOrEqualsElement(boundaryElement, target) || _visualEditing.containsOrEqualsElement(portalElement, target);
}
const StyledDialog = /* @__PURE__ */ styledComponents.styled(_visualEditing.Layer).withConfig({
  displayName: "StyledDialog",
  componentId: "sc-4n4xb3-0"
})(_visualEditing.responsivePaddingStyle, dialogStyle, responsiveDialogPositionStyle, animationDialogStyle), DialogContainer = styledComponents.styled(_visualEditing.Container).withConfig({
  displayName: "DialogContainer",
  componentId: "sc-4n4xb3-1"
})`&:not([hidden]){display:flex;}width:100%;height:100%;flex-direction:column;align-items:center;justify-content:center;`, DialogCardRoot = styledComponents.styled(_visualEditing.Card).withConfig({
  displayName: "DialogCardRoot",
  componentId: "sc-4n4xb3-2"
})`&:not([hidden]){display:flex;}width:100%;min-height:0;max-height:100%;overflow:hidden;overflow:clip;`, DialogLayout = styledComponents.styled(_visualEditing.Flex).withConfig({
  displayName: "DialogLayout",
  componentId: "sc-4n4xb3-3"
})`flex:1;min-height:0;width:100%;`, DialogHeader = styledComponents.styled(_visualEditing.Box).withConfig({
  displayName: "DialogHeader",
  componentId: "sc-4n4xb3-4"
})`position:relative;z-index:2;`, DialogContent = styledComponents.styled(_visualEditing.Box).withConfig({
  displayName: "DialogContent",
  componentId: "sc-4n4xb3-5"
})`position:relative;z-index:1;overflow:auto;outline:none;`, DialogFooter = styledComponents.styled(_visualEditing.Box).withConfig({
  displayName: "DialogFooter",
  componentId: "sc-4n4xb3-6"
})`position:relative;z-index:3;`, DialogCard = react.forwardRef(function(props, forwardedRef) {
  const $ = reactCompilerRuntime.c(38), {
    __unstable_autoFocus: autoFocus,
    __unstable_hideCloseButton: hideCloseButton,
    children,
    contentRef: forwardedContentRef,
    footer,
    header,
    id,
    onClickOutside,
    onClose,
    portal: portalProp,
    radius: radiusProp,
    scheme,
    shadow: shadowProp,
    width: widthProp
  } = props, portal = _visualEditing.usePortal(), portalElement = portalProp ? portal.elements?.[portalProp] || null : portal.element, boundaryElement = _visualEditing.useBoundaryElement().element, radius = _visualEditing.useArrayProp(radiusProp), shadow = _visualEditing.useArrayProp(shadowProp), width = _visualEditing.useArrayProp(widthProp), ref = react.useRef(null), contentRef = react.useRef(null), layer = _visualEditing.useLayer(), {
    isTopLayer
  } = layer, labelId = `${id}_label`, showCloseButton = !!onClose && hideCloseButton === !1, showHeader = !!header || showCloseButton;
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => ref.current, $[0] = t0) : t0 = $[0], react.useImperativeHandle(forwardedRef, t0);
  let t1;
  $[1] === Symbol.for("react.memo_cache_sentinel") ? (t1 = () => contentRef.current, $[1] = t1) : t1 = $[1], react.useImperativeHandle(forwardedContentRef, t1);
  let t2, t3;
  $[2] !== autoFocus ? (t2 = () => {
    autoFocus && ref.current && focusFirstDescendant(ref.current);
  }, t3 = [autoFocus, ref], $[2] = autoFocus, $[3] = t2, $[4] = t3) : (t2 = $[3], t3 = $[4]), react.useEffect(t2, t3);
  let t4;
  $[5] !== boundaryElement || $[6] !== isTopLayer || $[7] !== onClose || $[8] !== portalElement ? (t4 = (event) => {
    if (!isTopLayer || !onClose)
      return;
    const target = document.activeElement;
    target && !isTargetWithinScope(boundaryElement, portalElement, target) || event.key === "Escape" && (event.preventDefault(), event.stopPropagation(), onClose());
  }, $[5] = boundaryElement, $[6] = isTopLayer, $[7] = onClose, $[8] = portalElement, $[9] = t4) : t4 = $[9], _visualEditing.useGlobalKeyDown(t4);
  let t5;
  $[10] !== boundaryElement || $[11] !== isTopLayer || $[12] !== onClickOutside || $[13] !== portalElement ? (t5 = isTopLayer && onClickOutside && ((event_0) => {
    const target_0 = event_0.target;
    target_0 && !isTargetWithinScope(boundaryElement, portalElement, target_0) || onClickOutside();
  }), $[10] = boundaryElement, $[11] = isTopLayer, $[12] = onClickOutside, $[13] = portalElement, $[14] = t5) : t5 = $[14];
  let t6;
  $[15] === Symbol.for("react.memo_cache_sentinel") ? (t6 = () => [ref.current], $[15] = t6) : t6 = $[15], _visualEditing.useClickOutsideEvent(t5, t6);
  let t7;
  $[16] !== header || $[17] !== labelId || $[18] !== onClose || $[19] !== showCloseButton || $[20] !== showHeader ? (t7 = showHeader && /* @__PURE__ */ jsxRuntime.jsx(DialogHeader, { children: /* @__PURE__ */ jsxRuntime.jsxs(_visualEditing.Flex, { align: "flex-start", padding: 3, children: [
    /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Box, { flex: 1, padding: 2, children: header && /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Text, { id: labelId, size: 1, weight: "semibold", children: header }) }),
    showCloseButton && /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Box, { flex: "none", children: /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Button, { "aria-label": "Close dialog", disabled: !onClose, icon: icons.CloseIcon, mode: "bleed", onClick: onClose, padding: 2 }) })
  ] }) }), $[16] = header, $[17] = labelId, $[18] = onClose, $[19] = showCloseButton, $[20] = showHeader, $[21] = t7) : t7 = $[21];
  let t8;
  $[22] !== children ? (t8 = /* @__PURE__ */ jsxRuntime.jsx(DialogContent, { flex: 1, ref: contentRef, tabIndex: -1, children }), $[22] = children, $[23] = t8) : t8 = $[23];
  let t9;
  $[24] !== footer ? (t9 = footer && /* @__PURE__ */ jsxRuntime.jsx(DialogFooter, { children: footer }), $[24] = footer, $[25] = t9) : t9 = $[25];
  let t10;
  $[26] !== t7 || $[27] !== t8 || $[28] !== t9 ? (t10 = /* @__PURE__ */ jsxRuntime.jsxs(DialogLayout, { direction: "column", children: [
    t7,
    t8,
    t9
  ] }), $[26] = t7, $[27] = t8, $[28] = t9, $[29] = t10) : t10 = $[29];
  let t11;
  $[30] !== radius || $[31] !== scheme || $[32] !== shadow || $[33] !== t10 ? (t11 = /* @__PURE__ */ jsxRuntime.jsx(DialogCardRoot, { radius, ref, scheme, shadow, children: t10 }), $[30] = radius, $[31] = scheme, $[32] = shadow, $[33] = t10, $[34] = t11) : t11 = $[34];
  let t12;
  return $[35] !== t11 || $[36] !== width ? (t12 = /* @__PURE__ */ jsxRuntime.jsx(DialogContainer, { "data-ui": "DialogCard", width, children: t11 }), $[35] = t11, $[36] = width, $[37] = t12) : t12 = $[37], t12;
});
DialogCard.displayName = "ForwardRef(DialogCard)";
const Dialog = react.forwardRef(function(props, ref) {
  const $ = reactCompilerRuntime.c(60), dialog = useDialog(), {
    layer
  } = _visualEditing.useTheme_v2();
  let _positionProp, _zOffsetProp, children, contentRef, footer, header, id, onActivate, onClickOutside, onClose, onFocus, portalProp, restProps, scheme, t0, t1, t2, t3, t4, t5, t6;
  $[0] !== props ? ({
    __unstable_autoFocus: t0,
    __unstable_hideCloseButton: t1,
    cardRadius: t2,
    cardShadow: t3,
    children,
    contentRef,
    footer,
    header,
    id,
    onActivate,
    onClickOutside,
    onClose,
    onFocus,
    padding: t4,
    portal: portalProp,
    position: _positionProp,
    scheme,
    width: t5,
    zOffset: _zOffsetProp,
    animate: t6,
    ...restProps
  } = props, $[0] = props, $[1] = _positionProp, $[2] = _zOffsetProp, $[3] = children, $[4] = contentRef, $[5] = footer, $[6] = header, $[7] = id, $[8] = onActivate, $[9] = onClickOutside, $[10] = onClose, $[11] = onFocus, $[12] = portalProp, $[13] = restProps, $[14] = scheme, $[15] = t0, $[16] = t1, $[17] = t2, $[18] = t3, $[19] = t4, $[20] = t5, $[21] = t6) : (_positionProp = $[1], _zOffsetProp = $[2], children = $[3], contentRef = $[4], footer = $[5], header = $[6], id = $[7], onActivate = $[8], onClickOutside = $[9], onClose = $[10], onFocus = $[11], portalProp = $[12], restProps = $[13], scheme = $[14], t0 = $[15], t1 = $[16], t2 = $[17], t3 = $[18], t4 = $[19], t5 = $[20], t6 = $[21]);
  const autoFocus = t0 === void 0 ? !0 : t0, hideCloseButton = t1 === void 0 ? !1 : t1, cardRadiusProp = t2 === void 0 ? 4 : t2, cardShadow = t3 === void 0 ? 3 : t3, paddingProp = t4 === void 0 ? 3 : t4, widthProp = t5 === void 0 ? 0 : t5, _animate = t6 === void 0 ? !1 : t6, positionProp = _positionProp ?? (dialog.position || "fixed"), zOffsetProp = _zOffsetProp ?? (dialog.zOffset || layer.dialog.zOffset), animate = _visualEditing.usePrefersReducedMotion() ? !1 : _animate, portal = _visualEditing.usePortal(), portalElement = portalProp ? portal.elements?.[portalProp] || null : portal.element, boundaryElement = _visualEditing.useBoundaryElement().element, cardRadius = _visualEditing.useArrayProp(cardRadiusProp), padding = _visualEditing.useArrayProp(paddingProp), position = _visualEditing.useArrayProp(positionProp), width = _visualEditing.useArrayProp(widthProp), zOffset = _visualEditing.useArrayProp(zOffsetProp), preDivRef = react.useRef(null), postDivRef = react.useRef(null), cardRef = react.useRef(null), focusedElementRef = react.useRef(null);
  let t7;
  $[22] !== onFocus ? (t7 = (event) => {
    onFocus?.(event);
    const target = event.target, cardElement = cardRef.current;
    if (cardElement && target === preDivRef.current) {
      focusLastDescendant(cardElement);
      return;
    }
    if (cardElement && target === postDivRef.current) {
      focusFirstDescendant(cardElement);
      return;
    }
    _visualEditing.isHTMLElement(event.target) && (focusedElementRef.current = event.target);
  }, $[22] = onFocus, $[23] = t7) : t7 = $[23];
  const handleFocus = t7, labelId = `${id}_label`, rootClickTimeoutRef = react.useRef(void 0);
  let t8;
  $[24] !== boundaryElement || $[25] !== portalElement ? (t8 = () => {
    rootClickTimeoutRef.current && clearTimeout(rootClickTimeoutRef.current), rootClickTimeoutRef.current = setTimeout(() => {
      const activeElement = document.activeElement;
      if (activeElement && !isTargetWithinScope(boundaryElement, portalElement, activeElement)) {
        const target_0 = focusedElementRef.current;
        if (!target_0 || !document.body.contains(target_0)) {
          const cardElement_0 = cardRef.current;
          cardElement_0 && focusFirstDescendant(cardElement_0);
          return;
        }
        target_0.focus();
      }
    }, 0);
  }, $[24] = boundaryElement, $[25] = portalElement, $[26] = t8) : t8 = $[26];
  const handleRootClick = t8;
  let t9;
  $[27] === Symbol.for("react.memo_cache_sentinel") ? (t9 = /* @__PURE__ */ jsxRuntime.jsx("div", { ref: preDivRef, tabIndex: 0 }), $[27] = t9) : t9 = $[27];
  let t10;
  $[28] !== autoFocus || $[29] !== cardRadius || $[30] !== cardShadow || $[31] !== children || $[32] !== contentRef || $[33] !== footer || $[34] !== header || $[35] !== hideCloseButton || $[36] !== id || $[37] !== onClickOutside || $[38] !== onClose || $[39] !== portalProp || $[40] !== scheme || $[41] !== width ? (t10 = /* @__PURE__ */ jsxRuntime.jsx(DialogCard, { __unstable_autoFocus: autoFocus, __unstable_hideCloseButton: hideCloseButton, contentRef, footer, header, id, onClickOutside, onClose, portal: portalProp, radius: cardRadius, ref: cardRef, scheme, shadow: cardShadow, width, children }), $[28] = autoFocus, $[29] = cardRadius, $[30] = cardShadow, $[31] = children, $[32] = contentRef, $[33] = footer, $[34] = header, $[35] = hideCloseButton, $[36] = id, $[37] = onClickOutside, $[38] = onClose, $[39] = portalProp, $[40] = scheme, $[41] = width, $[42] = t10) : t10 = $[42];
  let t11;
  $[43] === Symbol.for("react.memo_cache_sentinel") ? (t11 = /* @__PURE__ */ jsxRuntime.jsx("div", { ref: postDivRef, tabIndex: 0 }), $[43] = t11) : t11 = $[43];
  let t12;
  $[44] !== animate || $[45] !== handleFocus || $[46] !== handleRootClick || $[47] !== id || $[48] !== labelId || $[49] !== onActivate || $[50] !== padding || $[51] !== position || $[52] !== ref || $[53] !== restProps || $[54] !== t10 || $[55] !== zOffset ? (t12 = /* @__PURE__ */ jsxRuntime.jsxs(StyledDialog, { ...restProps, $animate: animate, $padding: padding, $position: position, "aria-labelledby": labelId, "aria-modal": !0, "data-ui": "Dialog", id, onActivate, onClick: handleRootClick, onFocus: handleFocus, ref, role: "dialog", zOffset, children: [
    t9,
    t10,
    t11
  ] }), $[44] = animate, $[45] = handleFocus, $[46] = handleRootClick, $[47] = id, $[48] = labelId, $[49] = onActivate, $[50] = padding, $[51] = position, $[52] = ref, $[53] = restProps, $[54] = t10, $[55] = zOffset, $[56] = t12) : t12 = $[56];
  let t13;
  return $[57] !== portalProp || $[58] !== t12 ? (t13 = /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Portal, { __unstable_name: portalProp, children: t12 }), $[57] = portalProp, $[58] = t12, $[59] = t13) : t13 = $[59], t13;
});
Dialog.displayName = "ForwardRef(Dialog)";
function DialogProvider(props) {
  const $ = reactCompilerRuntime.c(6), {
    children,
    position,
    zOffset
  } = props;
  let t0, t1;
  $[0] !== position || $[1] !== zOffset ? (t1 = {
    version: 0,
    position,
    zOffset
  }, $[0] = position, $[1] = zOffset, $[2] = t1) : t1 = $[2], t0 = t1;
  const contextValue = t0;
  let t2;
  return $[3] !== children || $[4] !== contextValue ? (t2 = /* @__PURE__ */ jsxRuntime.jsx(DialogContext.Provider, { value: contextValue, children }), $[3] = children, $[4] = contextValue, $[5] = t2) : t2 = $[5], t2;
}
DialogProvider.displayName = "DialogProvider";
const MenuButton = react.forwardRef(function(props, forwardedRef) {
  const {
    __unstable_disableRestoreFocusOnClose: disableRestoreFocusOnClose = !1,
    boundaryElement: deprecated_boundaryElement,
    button: buttonProp,
    id,
    menu: menuProp,
    onClose,
    onOpen,
    placement: deprecated_placement,
    popoverScheme: deprecated_popoverScheme,
    portal: deprecated_portal = !0,
    popover,
    popoverRadius: deprecated_popoverRadius,
    preventOverflow: deprecated_preventOverflow
  } = props, [open, setOpen] = react.useState(!1), [shouldFocus, setShouldFocus] = react.useState(null), [buttonElement, setButtonElement] = react.useState(null), [menuElements, setChildMenuElements] = react.useState([]), openRef = react.useRef(open);
  react.useEffect(() => {
    onOpen && open && !openRef.current && onOpen();
  }, [onOpen, open]), react.useEffect(() => {
    onClose && !open && openRef.current && onClose();
  }, [onClose, open]), react.useEffect(() => {
    openRef.current = open;
  }, [open]);
  const handleButtonClick = react.useCallback(() => {
    setOpen((v) => !v), setShouldFocus(null);
  }, []), handleMouseDown = react.useCallback((event) => {
    open && event.preventDefault();
  }, [open]), handleButtonKeyDown = react.useCallback((event_0) => {
    if (event_0.key === "ArrowDown" || event_0.key === "Enter" || event_0.key === " ") {
      event_0.preventDefault(), setOpen(!0), setShouldFocus("first");
      return;
    }
    if (event_0.key === "ArrowUp") {
      event_0.preventDefault(), setOpen(!0), setShouldFocus("last");
      return;
    }
  }, []), handleMenuClickOutside = react.useCallback((event_1) => {
    const target = event_1.target;
    if (target instanceof Node && !(buttonElement && (target === buttonElement || buttonElement.contains(target)))) {
      for (const el of menuElements)
        if (target === el || el.contains(target))
          return;
      setOpen(!1);
    }
  }, [buttonElement, menuElements]), handleMenuEscape = react.useCallback(() => {
    setOpen(!1), !disableRestoreFocusOnClose && buttonElement && buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]), handleBlur = react.useCallback((event_2) => {
    const target_0 = event_2.relatedTarget;
    if (target_0 instanceof Node) {
      for (const el_0 of menuElements)
        if (el_0 === target_0 || el_0.contains(target_0))
          return;
      setOpen(!1);
    }
  }, [menuElements]), handleItemClick = react.useCallback(() => {
    setOpen(!1), !disableRestoreFocusOnClose && buttonElement && buttonElement.focus();
  }, [buttonElement, disableRestoreFocusOnClose]), registerElement = react.useCallback((el_1) => (setChildMenuElements((els) => els.concat([el_1])), () => setChildMenuElements((els_0) => els_0.filter((_el) => _el !== el_1))), []), menu = menuProp && react.cloneElement(menuProp, {
    "aria-labelledby": id,
    onBlurCapture: handleBlur,
    onClickOutside: handleMenuClickOutside,
    onEscape: handleMenuEscape,
    onItemClick: handleItemClick,
    originElement: buttonElement,
    registerElement,
    shouldFocus
  }), button = react.useMemo(() => buttonProp && react.cloneElement(buttonProp, {
    "data-ui": "MenuButton",
    id,
    onClick: handleButtonClick,
    onKeyDown: handleButtonKeyDown,
    onMouseDown: handleMouseDown,
    "aria-haspopup": !0,
    "aria-expanded": open,
    ref: setButtonElement,
    selected: buttonProp.props.selected ?? open
  }), [buttonProp, handleButtonClick, handleButtonKeyDown, handleMouseDown, id, open]);
  react.useImperativeHandle(forwardedRef, () => buttonElement, [buttonElement]);
  const popoverProps = react.useMemo(() => ({
    boundaryElement: deprecated_boundaryElement,
    overflow: "auto",
    placement: deprecated_placement,
    portal: deprecated_portal,
    preventOverflow: deprecated_preventOverflow,
    radius: deprecated_popoverRadius,
    scheme: deprecated_popoverScheme,
    ...popover || {}
  }), [deprecated_boundaryElement, deprecated_placement, deprecated_popoverRadius, deprecated_popoverScheme, deprecated_portal, deprecated_preventOverflow, popover]);
  return /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Popover, { "data-ui": "MenuButton__popover", ...popoverProps, content: menu, open, children: button || /* @__PURE__ */ jsxRuntime.jsx(jsxRuntime.Fragment, {}) });
});
MenuButton.displayName = "ForwardRef(MenuButton)";
const keyframe = styledComponents.keyframes`
  0% {
    background-position: 100%;
  }
  100% {
    background-position: -100%;
  }
`, animation = styledComponents.css`
  background-image: linear-gradient(
    to right,
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-to),
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-from),
    var(--card-skeleton-color-from)
  );
  background-position: 100%;
  background-size: 200% 100%;
  background-attachment: fixed;
  animation-name: ${keyframe};
  animation-timing-function: ease-in-out;
  animation-iteration-count: infinite;
  animation-duration: 2000ms;
`, skeletonStyle = styledComponents.css`
  opacity: ${({
  $visible
}) => $visible ? 1 : 0};
  transition: opacity 200ms ease-in;

  @media screen and (prefers-reduced-motion: no-preference) {
    ${({
  $animated
}) => $animated ? animation : styledComponents.css`
            background-color: var(--card-skeleton-color-from);
          `}
  }

  @media screen and (prefers-reduced-motion: reduce) {
    background-color: var(--card-skeleton-color-from);
  }
`, StyledSkeleton$1 = /* @__PURE__ */ styledComponents.styled(_visualEditing.Box).withConfig({
  displayName: "StyledSkeleton",
  componentId: "sc-ebtpni-0"
})(_visualEditing.responsiveRadiusStyle, skeletonStyle), Skeleton = react.forwardRef(function(props, ref) {
  const $ = reactCompilerRuntime.c(14);
  let delay, radius, restProps, t0;
  $[0] !== props ? ({
    animated: t0,
    delay,
    radius,
    ...restProps
  } = props, $[0] = props, $[1] = delay, $[2] = radius, $[3] = restProps, $[4] = t0) : (delay = $[1], radius = $[2], restProps = $[3], t0 = $[4]);
  const animated = t0 === void 0 ? !1 : t0, [visible, setVisible] = react.useState(!delay);
  let t1, t2;
  $[5] !== delay ? (t1 = () => {
    if (!delay)
      return setVisible(!0);
    const timeout = setTimeout(() => {
      setVisible(!0);
    }, delay);
    return () => {
      clearTimeout(timeout);
    };
  }, t2 = [delay], $[5] = delay, $[6] = t1, $[7] = t2) : (t1 = $[6], t2 = $[7]), react.useEffect(t1, t2);
  const t3 = _visualEditing.useArrayProp(radius);
  let t4;
  return $[8] !== animated || $[9] !== ref || $[10] !== restProps || $[11] !== t3 || $[12] !== visible ? (t4 = /* @__PURE__ */ jsxRuntime.jsx(StyledSkeleton$1, { ...restProps, $animated: animated, $radius: t3, $visible: visible, ref }), $[8] = animated, $[9] = ref, $[10] = restProps, $[11] = t3, $[12] = visible, $[13] = t4) : t4 = $[13], t4;
});
Skeleton.displayName = "ForwardRef(Skeleton)";
const StyledSkeleton = /* @__PURE__ */ styledComponents.styled(Skeleton).withConfig({
  displayName: "StyledSkeleton",
  componentId: "sc-2p7a1v-0"
})((props) => {
  const {
    $size,
    $style
  } = props, {
    font,
    media
  } = theme.getTheme_v2(props.theme), fontStyle = font[$style];
  return _visualEditing._responsive(media, $size, (sizeIndex) => {
    const fontSize = fontStyle.sizes[sizeIndex];
    return {
      height: fontSize.lineHeight - fontSize.ascenderHeight - fontSize.descenderHeight
    };
  });
}), TextSkeleton = react.forwardRef(function(props, ref) {
  const $ = reactCompilerRuntime.c(7);
  let restProps, t0;
  $[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $[0] = props, $[1] = restProps, $[2] = t0) : (restProps = $[1], t0 = $[2]);
  const $size = _visualEditing.useArrayProp(t0 === void 0 ? 2 : t0);
  let t1;
  return $[3] !== $size || $[4] !== ref || $[5] !== restProps ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(StyledSkeleton, { ...restProps, $size, ref, $style: "text" }), $[3] = $size, $[4] = ref, $[5] = restProps, $[6] = t1) : t1 = $[6], t1;
});
TextSkeleton.displayName = "ForwardRef(TextSkeleton)";
const LabelSkeleton = react.forwardRef(function(props, ref) {
  const $ = reactCompilerRuntime.c(7);
  let restProps, t0;
  $[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $[0] = props, $[1] = restProps, $[2] = t0) : (restProps = $[1], t0 = $[2]);
  const $size = _visualEditing.useArrayProp(t0 === void 0 ? 2 : t0);
  let t1;
  return $[3] !== $size || $[4] !== ref || $[5] !== restProps ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(StyledSkeleton, { ...restProps, $size, ref, $style: "label" }), $[3] = $size, $[4] = ref, $[5] = restProps, $[6] = t1) : t1 = $[6], t1;
});
LabelSkeleton.displayName = "ForwardRef(LabelSkeleton)";
const HeadingSkeleton = react.forwardRef(function(props, ref) {
  const $ = reactCompilerRuntime.c(7);
  let restProps, t0;
  $[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $[0] = props, $[1] = restProps, $[2] = t0) : (restProps = $[1], t0 = $[2]);
  const $size = _visualEditing.useArrayProp(t0 === void 0 ? 2 : t0);
  let t1;
  return $[3] !== $size || $[4] !== ref || $[5] !== restProps ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(StyledSkeleton, { ...restProps, $size, ref, $style: "heading" }), $[3] = $size, $[4] = ref, $[5] = restProps, $[6] = t1) : t1 = $[6], t1;
});
HeadingSkeleton.displayName = "ForwardRef(HeadingSkeleton)";
const CodeSkeleton = react.forwardRef(function(props, ref) {
  const $ = reactCompilerRuntime.c(7);
  let restProps, t0;
  $[0] !== props ? ({
    size: t0,
    ...restProps
  } = props, $[0] = props, $[1] = restProps, $[2] = t0) : (restProps = $[1], t0 = $[2]);
  const $size = _visualEditing.useArrayProp(t0 === void 0 ? 2 : t0);
  let t1;
  return $[3] !== $size || $[4] !== ref || $[5] !== restProps ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(StyledSkeleton, { ...restProps, $size, ref, $style: "code" }), $[3] = $size, $[4] = ref, $[5] = restProps, $[6] = t1) : t1 = $[6], t1;
});
CodeSkeleton.displayName = "ForwardRef(CodeSkeleton)";
const TabPanel = react.forwardRef(function(props, ref) {
  const $ = reactCompilerRuntime.c(9);
  let flex, restProps;
  $[0] !== props ? ({
    flex,
    ...restProps
  } = props, $[0] = props, $[1] = flex, $[2] = restProps) : (flex = $[1], restProps = $[2]);
  const t0 = props.tabIndex === void 0 ? 0 : props.tabIndex;
  let t1;
  return $[3] !== flex || $[4] !== props.children || $[5] !== ref || $[6] !== restProps || $[7] !== t0 ? (t1 = /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Box, { "data-ui": "TabPanel", ...restProps, flex, ref, role: "tabpanel", tabIndex: t0, children: props.children }), $[3] = flex, $[4] = props.children, $[5] = ref, $[6] = restProps, $[7] = t0, $[8] = t1) : t1 = $[8], t1;
});
TabPanel.displayName = "ForwardRef(TabPanel)";
const TextBox = styledComponents.styled(_visualEditing.Flex).withConfig({
  displayName: "TextBox",
  componentId: "sc-1rr7rxo-0"
})`overflow-x:auto;`, loadingAnimation = styledComponents.keyframes`
  0% {
    width: 0;
  }
  100% {
    width: 100%;
  }
`, LOADING_BAR_HEIGHT = 2;
function rootStyles(props) {
  const {
    color
  } = getTheme_v2.getTheme_v2(props.theme), loadingBarColor = color.button.default[props.tone].enabled.bg;
  return props.$duration ? styledComponents.css`
    pointer-events: all;
    width: 100%;
    position: relative;
    overflow: hidden;
    overflow: clip;
    padding-bottom: ${LOADING_BAR_HEIGHT}px;
    &::before {
      content: '';
      position: absolute;
      bottom: 0px;
      height: ${LOADING_BAR_HEIGHT}px;
      background: ${loadingBarColor};
      animation-name: ${loadingAnimation};
      animation-duration: ${props.$duration}ms;
      animation-fill-mode: both;
    }

    & > * {
      opacity: var(${_visualEditing.POPOVER_MOTION_CONTENT_OPACITY_PROPERTY}, 1);
      will-change: opacity;
    }
  ` : styledComponents.css`
      pointer-events: all;
      & > * {
        opacity: var(${_visualEditing.POPOVER_MOTION_CONTENT_OPACITY_PROPERTY}, 1);
        will-change: opacity;
      }
    `;
}
const STATUS_CARD_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "neutral"
}, BUTTON_TONE = {
  error: "critical",
  warning: "caution",
  success: "positive",
  info: "neutral"
}, ROLES = {
  error: "alert",
  warning: "alert",
  success: "alert",
  info: "alert"
}, StyledToast = /* @__PURE__ */ styledComponents.styled(_visualEditing.Card).withConfig({
  displayName: "StyledToast",
  componentId: "sc-1icz8ea-0"
})(rootStyles);
function Toast(props) {
  const $ = reactCompilerRuntime.c(30);
  let closable, description, duration, onClose, restProps, status, t0, title;
  $[0] !== props ? ({
    closable,
    description,
    duration,
    onClose,
    radius: t0,
    title,
    status,
    ...restProps
  } = props, $[0] = props, $[1] = closable, $[2] = description, $[3] = duration, $[4] = onClose, $[5] = restProps, $[6] = status, $[7] = t0, $[8] = title) : (closable = $[1], description = $[2], duration = $[3], onClose = $[4], restProps = $[5], status = $[6], t0 = $[7], title = $[8]);
  const radius = t0 === void 0 ? 3 : t0, cardTone = status ? STATUS_CARD_TONE[status] : "default", buttonTone = status ? BUTTON_TONE[status] : "default", role = status ? ROLES[status] : "status";
  let t1;
  $[9] !== title ? (t1 = title && /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Text, { size: 1, weight: "medium", children: title }), $[9] = title, $[10] = t1) : t1 = $[10];
  let t2;
  $[11] !== description ? (t2 = description && /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Text, { muted: !0, size: 1, children: description }), $[11] = description, $[12] = t2) : t2 = $[12];
  let t3;
  $[13] !== t1 || $[14] !== t2 ? (t3 = /* @__PURE__ */ jsxRuntime.jsx(TextBox, { flex: 1, padding: 3, children: /* @__PURE__ */ jsxRuntime.jsxs(_visualEditing.Stack, { space: 3, children: [
    t1,
    t2
  ] }) }), $[13] = t1, $[14] = t2, $[15] = t3) : t3 = $[15];
  let t4;
  $[16] !== buttonTone || $[17] !== closable || $[18] !== onClose ? (t4 = closable && /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Box, { padding: 1, children: /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Button, { as: "button", icon: icons.CloseIcon, mode: "bleed", padding: 2, tone: buttonTone, onClick: onClose, style: {
    verticalAlign: "top"
  } }) }), $[16] = buttonTone, $[17] = closable, $[18] = onClose, $[19] = t4) : t4 = $[19];
  let t5;
  $[20] !== t3 || $[21] !== t4 ? (t5 = /* @__PURE__ */ jsxRuntime.jsxs(_visualEditing.Flex, { align: "flex-start", children: [
    t3,
    t4
  ] }), $[20] = t3, $[21] = t4, $[22] = t5) : t5 = $[22];
  let t6;
  return $[23] !== cardTone || $[24] !== duration || $[25] !== radius || $[26] !== restProps || $[27] !== role || $[28] !== t5 ? (t6 = /* @__PURE__ */ jsxRuntime.jsx(StyledToast, { "data-ui": "Toast", role, ...restProps, marginTop: 3, radius, shadow: 2, tone: cardTone, $duration: duration, children: t5 }), $[23] = cardTone, $[24] = duration, $[25] = radius, $[26] = restProps, $[27] = role, $[28] = t5, $[29] = t6) : t6 = $[29], t6;
}
Toast.displayName = "Toast";
function useMounted() {
  return react.useSyncExternalStore(subscribe, _temp, _temp2);
}
function _temp2() {
  return !1;
}
function _temp() {
  return !0;
}
const subscribe = () => () => {
}, ToastContext = _visualEditing.createGlobalScopedContext("@sanity/ui/context/toast", null);
let toastId = 0;
function generateToastId() {
  return String(toastId++);
}
const StyledToastProvider = styledComponents.styled(_visualEditing.Layer).withConfig({
  displayName: "StyledToastProvider",
  componentId: "sc-17mn6j-0"
})`position:fixed;top:0;left:0;right:0;bottom:0;pointer-events:none;`, ToastContainer = styledComponents.styled.div.withConfig({
  displayName: "ToastContainer",
  componentId: "sc-17mn6j-1"
})`box-sizing:border-box;position:absolute;right:0;bottom:0;max-width:420px;width:100%;`;
function ToastProvider(props) {
  const $ = reactCompilerRuntime.c(24), {
    children,
    padding: t0,
    paddingX,
    paddingY,
    zOffset
  } = props, padding = t0 === void 0 ? 4 : t0;
  let t1;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t1 = [], $[0] = t1) : t1 = $[0];
  const [state, _setState] = react.useState(t1);
  let t2;
  $[1] === Symbol.for("react.memo_cache_sentinel") ? (t2 = {}, $[1] = t2) : t2 = $[1];
  const toastsRef = react.useRef(t2), mounted = useMounted(), prefersReducedMotion = _visualEditing.usePrefersReducedMotion();
  let t3, t4, t5;
  $[2] === Symbol.for("react.memo_cache_sentinel") ? (t4 = {
    opacity: 0,
    [_visualEditing.POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: 0,
    y: 32,
    scale: 0.25,
    willChange: "transform"
  }, t5 = [0, 1, 1], $[2] = t4, $[3] = t5) : (t4 = $[2], t5 = $[3]);
  let t6, t7;
  $[4] === Symbol.for("react.memo_cache_sentinel") ? (t6 = {
    opacity: t5,
    [_visualEditing.POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: [0, 0, 1],
    y: 0,
    scale: 1
  }, t7 = [1, 1, 0], $[4] = t6, $[5] = t7) : (t6 = $[4], t7 = $[5]);
  let t8;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t8 = [1, 0, 0], $[6] = t8) : t8 = $[6];
  const t9 = prefersReducedMotion ? 0 : 0.2;
  let t10;
  $[7] !== t9 ? (t10 = {
    initial: t4,
    animate: t6,
    exit: {
      opacity: t7,
      [_visualEditing.POPOVER_MOTION_CONTENT_OPACITY_PROPERTY]: t8,
      scale: 0.5,
      transition: {
        duration: t9
      }
    }
  }, $[7] = t9, $[8] = t10) : t10 = $[8], t3 = t10;
  const variants = t3;
  let t11, t12;
  $[9] === Symbol.for("react.memo_cache_sentinel") ? (t12 = {
    version: 0,
    push: (params) => {
      const setState = (state_0) => react.startTransition(() => _setState(state_0)), id = params.id || generateToastId(), duration = params.duration || 5e3, dismiss = () => {
        const timeoutId = toastsRef.current[id]?.timeoutId;
        setState((prevState) => {
          const idx = prevState.findIndex((t) => t.id === id);
          if (idx > -1) {
            const toasts = prevState.slice(0);
            return toasts.splice(idx, 1), toasts;
          }
          return prevState;
        }), timeoutId !== void 0 && (clearTimeout(timeoutId), delete toastsRef.current[id]);
      };
      return setState((prevState_0) => prevState_0.filter((t_0) => t_0.id !== id).concat([{
        dismiss,
        id,
        params: {
          ...params,
          duration
        }
      }])), toastsRef.current[id] && (clearTimeout(toastsRef.current[id].timeoutId), delete toastsRef.current[id]), toastsRef.current[id] = {
        timeoutId: setTimeout(dismiss, duration)
      }, id;
    }
  }, $[9] = t12) : t12 = $[9], t11 = t12;
  const value = t11;
  let t13, t14;
  $[10] === Symbol.for("react.memo_cache_sentinel") ? (t13 = () => () => {
    for (const {
      timeoutId: timeoutId_0
    } of Object.values(toastsRef.current))
      clearTimeout(timeoutId_0);
    toastsRef.current = {};
  }, t14 = [], $[10] = t13, $[11] = t14) : (t13 = $[10], t14 = $[11]), react.useEffect(t13, t14);
  let t15;
  $[12] !== mounted || $[13] !== padding || $[14] !== paddingX || $[15] !== paddingY || $[16] !== prefersReducedMotion || $[17] !== state || $[18] !== variants || $[19] !== zOffset ? (t15 = mounted && /* @__PURE__ */ jsxRuntime.jsx(StyledToastProvider, { "data-ui": "ToastProvider", zOffset, children: /* @__PURE__ */ jsxRuntime.jsx(ToastContainer, { children: /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Box, { padding, paddingX, paddingY, children: /* @__PURE__ */ jsxRuntime.jsx(framerMotion.AnimatePresence, { initial: !1, children: state.map((t162) => {
    const {
      dismiss: dismiss_0,
      id: id_0,
      params: params_0
    } = t162;
    return /* @__PURE__ */ jsxRuntime.jsx(framerMotion.motion.div, { layout: "position", initial: "initial", animate: "animate", exit: "exit", variants, transition: prefersReducedMotion ? {
      duration: 0
    } : {
      type: "spring",
      damping: 30,
      stiffness: 400
    }, children: /* @__PURE__ */ jsxRuntime.jsx(Toast, { closable: params_0.closable, description: params_0.description, onClose: dismiss_0, status: params_0.status, title: params_0.title, duration: params_0.duration }) }, id_0);
  }) }) }) }) }), $[12] = mounted, $[13] = padding, $[14] = paddingX, $[15] = paddingY, $[16] = prefersReducedMotion, $[17] = state, $[18] = variants, $[19] = zOffset, $[20] = t15) : t15 = $[20];
  let t16;
  return $[21] !== children || $[22] !== t15 ? (t16 = /* @__PURE__ */ jsxRuntime.jsxs(ToastContext.Provider, { value, children: [
    children,
    t15
  ] }), $[21] = children, $[22] = t15, $[23] = t16) : t16 = $[23], t16;
}
ToastProvider.displayName = "ToastProvider";
function useToast() {
  const value = react.useContext(ToastContext);
  if (!value)
    throw new Error("useToast(): missing context value");
  if (!_visualEditing.isRecord(value) || value.version !== 0)
    throw new Error("useToast(): the context value is not compatible");
  return value;
}
function _findPrevItemElement(state, itemElements, focusedElement) {
  const idx = itemElements.indexOf(focusedElement), els = itemElements.slice(0, idx), len = els.length;
  for (let i = len - 1; i >= 0; i -= 1) {
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey)
      continue;
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = !0;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!state[k]?.expanded) {
        expanded = !1;
        break;
      }
    }
    if (expanded)
      return els[i];
  }
  return null;
}
function _findNextItemElement(state, itemElements, focusedElement) {
  const idx = itemElements.indexOf(focusedElement), els = itemElements.slice(idx), len = itemElements.length;
  for (let i = 1; i < len; i += 1) {
    if (!els[i])
      continue;
    const itemKey = els[i].getAttribute("data-tree-key");
    if (!itemKey)
      continue;
    const segments = itemKey.split("/");
    segments.pop();
    const p = [];
    let expanded = !0;
    for (let j = 0; j < segments.length; j += 1) {
      p.push(segments[j]);
      const k = p.join("/");
      if (!state[k]?.expanded) {
        expanded = !1;
        break;
      }
    }
    if (expanded)
      return els[i];
  }
  return null;
}
function _focusItemElement(el) {
  if (el.getAttribute("role") === "treeitem" && el.focus(), el.getAttribute("role") === "none") {
    const firstChild = el.firstChild;
    firstChild && firstChild instanceof HTMLElement && firstChild.focus();
  }
}
const TreeContext = _visualEditing.createGlobalScopedContext("@sanity/ui/context/tree", null), Tree = react.memo(react.forwardRef(function(props, forwardedRef) {
  const $ = reactCompilerRuntime.c(37);
  let children, onFocus, restProps, t0;
  $[0] !== props ? ({
    children,
    space: t0,
    onFocus,
    ...restProps
  } = props, $[0] = props, $[1] = children, $[2] = onFocus, $[3] = restProps, $[4] = t0) : (children = $[1], onFocus = $[2], restProps = $[3], t0 = $[4]);
  const space = t0 === void 0 ? 1 : t0, ref = react.useRef(null), [focusedElement, setFocusedElement] = react.useState(null), focusedElementRef = react.useRef(focusedElement);
  let t1, t2;
  $[5] === Symbol.for("react.memo_cache_sentinel") ? (t2 = [], $[5] = t2) : t2 = $[5], t1 = t2;
  const path = t1;
  let t3;
  $[6] === Symbol.for("react.memo_cache_sentinel") ? (t3 = [], $[6] = t3) : t3 = $[6];
  const [itemElements, setItemElements] = react.useState(t3);
  let t4;
  $[7] === Symbol.for("react.memo_cache_sentinel") ? (t4 = {}, $[7] = t4) : t4 = $[7];
  const [state, setState] = react.useState(t4), stateRef = react.useRef(state);
  let t5;
  $[8] === Symbol.for("react.memo_cache_sentinel") ? (t5 = () => ref.current, $[8] = t5) : t5 = $[8], react.useImperativeHandle(forwardedRef, t5);
  let t6, t7;
  $[9] !== focusedElement ? (t6 = () => {
    focusedElementRef.current = focusedElement;
  }, t7 = [focusedElement], $[9] = focusedElement, $[10] = t6, $[11] = t7) : (t6 = $[10], t7 = $[11]), react.useEffect(t6, t7);
  let t8, t9;
  $[12] !== state ? (t8 = () => {
    stateRef.current = state;
  }, t9 = [state], $[12] = state, $[13] = t8, $[14] = t9) : (t8 = $[13], t9 = $[14]), react.useEffect(t8, t9);
  let t10;
  $[15] === Symbol.for("react.memo_cache_sentinel") ? (t10 = (element, path_0, expanded, selected) => (setState((s) => ({
    ...s,
    [path_0]: {
      element,
      expanded
    }
  })), selected && setFocusedElement(element), () => {
    setState((s_0) => {
      const newState = {
        ...s_0
      };
      return delete newState[path_0], newState;
    });
  }), $[15] = t10) : t10 = $[15];
  const registerItem = t10;
  let t11;
  $[16] === Symbol.for("react.memo_cache_sentinel") ? (t11 = (path_1, expanded_0) => {
    setState((s_1) => {
      const itemState = s_1[path_1];
      return itemState ? {
        ...s_1,
        [path_1]: {
          ...itemState,
          expanded: expanded_0
        }
      } : s_1;
    });
  }, $[16] = t11) : t11 = $[16];
  const setExpanded = t11;
  let t12;
  const t13 = focusedElement || itemElements[0] || null;
  let t14;
  $[17] !== space || $[18] !== state || $[19] !== t13 ? (t14 = {
    version: 0,
    focusedElement: t13,
    level: 0,
    path,
    registerItem,
    setExpanded,
    setFocusedElement,
    space,
    state
  }, $[17] = space, $[18] = state, $[19] = t13, $[20] = t14) : t14 = $[20], t12 = t14;
  const contextValue = t12;
  let t15;
  $[21] !== itemElements ? (t15 = (event) => {
    if (focusedElementRef.current) {
      if (event.key === "ArrowDown") {
        event.preventDefault();
        const nextEl = _findNextItemElement(stateRef.current, itemElements, focusedElementRef.current);
        nextEl && (_focusItemElement(nextEl), setFocusedElement(nextEl));
        return;
      }
      if (event.key === "ArrowUp") {
        event.preventDefault();
        const prevEl = _findPrevItemElement(stateRef.current, itemElements, focusedElementRef.current);
        prevEl && (_focusItemElement(prevEl), setFocusedElement(prevEl));
        return;
      }
      if (event.key === "ArrowLeft") {
        event.preventDefault();
        const itemKey = focusedElementRef.current.getAttribute("data-tree-key");
        if (!itemKey)
          return;
        const itemState_0 = stateRef.current[itemKey];
        if (!itemState_0)
          return;
        if (itemState_0.expanded)
          setState((s_2) => {
            const itemState_1 = s_2[itemKey];
            return itemState_1 ? {
              ...s_2,
              [itemKey]: {
                ...itemState_1,
                expanded: !1
              }
            } : s_2;
          });
        else {
          const itemPath = itemKey.split("/");
          itemPath.pop();
          const parentKey = itemPath.join("/"), parentState = parentKey && stateRef.current[parentKey];
          parentState && (parentState.element.focus(), setFocusedElement(parentState.element));
        }
        return;
      }
      if (event.key === "ArrowRight") {
        event.preventDefault();
        const focusedKey = focusedElementRef.current.getAttribute("data-tree-key");
        if (!focusedKey)
          return;
        stateRef.current[focusedKey]?.expanded || setState((s_3) => {
          const itemState_2 = s_3[focusedKey];
          return itemState_2 ? {
            ...s_3,
            [focusedKey]: {
              ...itemState_2,
              expanded: !0
            }
          } : s_3;
        });
        return;
      }
    }
  }, $[21] = itemElements, $[22] = t15) : t15 = $[22];
  const handleKeyDown = t15;
  let t16;
  $[23] !== onFocus ? (t16 = (event_0) => {
    setFocusedElement(event_0.target), onFocus?.(event_0);
  }, $[23] = onFocus, $[24] = t16) : t16 = $[24];
  const handleFocus = t16;
  let t17;
  $[25] === Symbol.for("react.memo_cache_sentinel") ? (t17 = () => {
    if (!ref.current)
      return;
    const _itemElements = Array.from(ref.current.querySelectorAll('[data-ui="TreeItem"]'));
    setItemElements(_itemElements);
  }, $[25] = t17) : t17 = $[25];
  let t18;
  $[26] !== children ? (t18 = [children], $[26] = children, $[27] = t18) : t18 = $[27], react.useEffect(t17, t18);
  let t19;
  $[28] !== children || $[29] !== handleFocus || $[30] !== handleKeyDown || $[31] !== restProps || $[32] !== space ? (t19 = /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Stack, { as: "ul", "data-ui": "Tree", ...restProps, onFocus: handleFocus, onKeyDown: handleKeyDown, ref, role: "tree", space, children }), $[28] = children, $[29] = handleFocus, $[30] = handleKeyDown, $[31] = restProps, $[32] = space, $[33] = t19) : t19 = $[33];
  let t20;
  return $[34] !== contextValue || $[35] !== t19 ? (t20 = /* @__PURE__ */ jsxRuntime.jsx(TreeContext.Provider, { value: contextValue, children: t19 }), $[34] = contextValue, $[35] = t19, $[36] = t20) : t20 = $[36], t20;
}));
Tree.displayName = "Memo(ForwardRef(Tree))";
function treeItemRootStyle() {
  return styledComponents.css`
    &[role='none'] > [role='treeitem'] {
      outline: none;
      cursor: default;
      border-radius: 3px;

      background-color: var(--card-bg-color);
      color: var(--treeitem-fg-color);

      &:focus {
        position: relative;
      }
    }

    &[role='treeitem'] {
      outline: none;

      & > div {
        cursor: default;
        border-radius: 3px;

        background-color: var(--card-bg-color);
        color: var(--treeitem-fg-color);
      }

      &:focus > div {
        position: relative;
      }
    }
  `;
}
function treeItemRootColorStyle(props) {
  const $tone = "default", {
    color
  } = theme.getTheme_v2(props.theme), tone = color.selectable[$tone];
  return styledComponents.css`
    &[role='none'] {
      & > [role='treeitem'] {
        ${_visualEditing._cardColorStyle(color, tone.enabled)}
      }

      &[data-selected] > [role='treeitem'] {
        ${_visualEditing._cardColorStyle(color, tone.pressed)}
      }

      @media (hover: hover) {
        &:not([data-selected]) > [role='treeitem']:not(:focus):hover {
          ${_visualEditing._cardColorStyle(color, tone.hovered)}
        }

        & > [role='treeitem']:focus {
          ${_visualEditing._cardColorStyle(color, tone.selected)}
        }
      }
    }

    &[role='treeitem'] {
      & > [data-ui='TreeItem__box'] {
        ${_visualEditing._cardColorStyle(color, tone.enabled)}
      }

      &[data-selected] > [data-ui='TreeItem__box'] {
        ${_visualEditing._cardColorStyle(color, tone.pressed)}
      }

      @media (hover: hover) {
        &:not([data-selected]):not(:focus) > [data-ui='TreeItem__box']:hover {
          ${_visualEditing._cardColorStyle(color, tone.hovered)}
        }

        &:focus > [data-ui='TreeItem__box'] {
          ${_visualEditing._cardColorStyle(color, tone.selected)}
        }
      }
    }
  `;
}
function treeItemBoxStyle(props) {
  const {
    $level
  } = props, {
    space
  } = theme.getTheme_v2(props.theme);
  return styledComponents.css`
    padding-left: ${_visualEditing.rem(space[2] * $level)};

    &[data-as='a'] {
      text-decoration: none;
    }
  `;
}
function useTree() {
  const tree = react.useContext(TreeContext);
  if (!tree)
    throw new Error("Tree: missing context value");
  return tree;
}
const TreeGroup = react.memo(function(props) {
  const $ = reactCompilerRuntime.c(9);
  let children, restProps, t0;
  $[0] !== props ? ({
    children,
    expanded: t0,
    ...restProps
  } = props, $[0] = props, $[1] = children, $[2] = restProps, $[3] = t0) : (children = $[1], restProps = $[2], t0 = $[3]);
  const expanded = t0 === void 0 ? !1 : t0, tree = useTree(), t1 = !expanded;
  let t2;
  return $[4] !== children || $[5] !== restProps || $[6] !== t1 || $[7] !== tree.space ? (t2 = /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Stack, { as: "ul", "data-ui": "TreeGroup", ...restProps, hidden: t1, marginTop: tree.space, role: "group", space: tree.space, children }), $[4] = children, $[5] = restProps, $[6] = t1, $[7] = tree.space, $[8] = t2) : t2 = $[8], t2;
}), StyledTreeItem = react.memo(styledComponents.styled.li.withConfig({
  displayName: "StyledTreeItem",
  componentId: "sc-iiskig-0"
})(treeItemRootStyle, treeItemRootColorStyle)), TreeItemBox = /* @__PURE__ */ styledComponents.styled(_visualEditing.Box).attrs({
  forwardedAs: "a"
}).withConfig({
  displayName: "TreeItemBox",
  componentId: "sc-iiskig-1"
})(treeItemBoxStyle), ToggleArrowText = styledComponents.styled(_visualEditing.Text).withConfig({
  displayName: "ToggleArrowText",
  componentId: "sc-iiskig-2"
})`& > svg{transition:transform 100ms;}`, TreeItem = react.memo(function(props) {
  const {
    children,
    expanded: expandedProp = !1,
    fontSize = 1,
    href,
    icon: IconComponent,
    id: idProp,
    linkAs,
    muted,
    onClick,
    padding = 2,
    selected = !1,
    space = 2,
    text,
    weight,
    ...restProps
  } = props, rootRef = react.useRef(null), treeitemRef = react.useRef(null), tree = useTree(), {
    path,
    registerItem,
    setExpanded,
    setFocusedElement
  } = tree, _id = react.useId(), id = idProp || _id, itemPath = react.useMemo(() => path.concat([id || ""]), [id, path]), itemKey = itemPath.join("/"), itemState = tree.state[itemKey], focused = tree.focusedElement === rootRef.current, expanded = itemState?.expanded === void 0 ? expandedProp : itemState?.expanded || !1, tabIndex = tree.focusedElement && tree.focusedElement === rootRef.current ? 0 : -1, contextValue = react.useMemo(() => ({
    ...tree,
    level: tree.level + 1,
    path: itemPath
  }), [itemPath, tree]), handleClick = react.useCallback((event) => {
    onClick && onClick(event);
    const target = event.target;
    target instanceof HTMLElement && (target.getAttribute("data-ui") === "TreeItem" || target.closest('[data-ui="TreeItem__box"]')) && (event.stopPropagation(), setExpanded(itemKey, !expanded), setFocusedElement(rootRef.current));
  }, [expanded, itemKey, onClick, setExpanded, setFocusedElement]), handleKeyDown = react.useCallback((event_0) => {
    focused && event_0.key === "Enter" && (treeitemRef.current || rootRef.current)?.click();
  }, [focused]);
  react.useEffect(() => {
    if (rootRef.current)
      return registerItem(rootRef.current, itemPath.join("/"), expanded, selected);
  }, [expanded, itemPath, registerItem, selected]);
  const content = /* @__PURE__ */ jsxRuntime.jsxs(_visualEditing.Flex, { padding, children: [
    /* @__PURE__ */ jsxRuntime.jsxs(_visualEditing.Box, { marginRight: space, style: {
      visibility: IconComponent || children ? "visible" : "hidden",
      pointerEvents: "none"
    }, children: [
      IconComponent && /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Text, { muted, size: fontSize, weight, children: /* @__PURE__ */ jsxRuntime.jsx(IconComponent, {}) }),
      !IconComponent && /* @__PURE__ */ jsxRuntime.jsx(ToggleArrowText, { muted, size: fontSize, weight, children: /* @__PURE__ */ jsxRuntime.jsx(icons.ToggleArrowRightIcon, { style: {
        transform: expanded ? "rotate(90deg)" : void 0
      } }) })
    ] }),
    /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Box, { flex: 1, children: /* @__PURE__ */ jsxRuntime.jsx(_visualEditing.Text, { muted, size: fontSize, textOverflow: "ellipsis", weight, children: text }) })
  ] });
  return href ? /* @__PURE__ */ jsxRuntime.jsxs(StyledTreeItem, { "data-selected": selected ? "" : void 0, "data-tree-id": id, "data-tree-key": itemKey, "data-ui": "TreeItem", ...restProps, onClick: handleClick, ref: rootRef, role: "none", children: [
    /* @__PURE__ */ jsxRuntime.jsx(TreeItemBox, { $level: tree.level, "aria-expanded": expanded, as: linkAs, "data-ui": "TreeItem__box", href, ref: treeitemRef, role: "treeitem", tabIndex, children: content }),
    /* @__PURE__ */ jsxRuntime.jsx(TreeContext.Provider, { value: contextValue, children: children && /* @__PURE__ */ jsxRuntime.jsx(TreeGroup, { hidden: !expanded, children }) })
  ] }) : /* @__PURE__ */ jsxRuntime.jsxs(StyledTreeItem, { "data-selected": selected ? "" : void 0, "data-ui": "TreeItem", "data-tree-id": id, "data-tree-key": itemKey, ...restProps, "aria-expanded": expanded, onClick: handleClick, onKeyDown: handleKeyDown, ref: rootRef, role: "treeitem", tabIndex, children: [
    /* @__PURE__ */ jsxRuntime.jsx(TreeItemBox, { $level: tree.level, as: "div", "data-ui": "TreeItem__box", children: content }),
    /* @__PURE__ */ jsxRuntime.jsx(TreeContext.Provider, { value: contextValue, children: children && /* @__PURE__ */ jsxRuntime.jsx(TreeGroup, { expanded, children }) })
  ] });
});
TreeItem.displayName = "Memo(TreeItem)";
exports.Arrow = _visualEditing.Arrow;
exports.Avatar = _visualEditing.Avatar;
exports.AvatarCounter = _visualEditing.AvatarCounter;
exports.AvatarStack = _visualEditing.AvatarStack;
exports.Badge = _visualEditing.Badge;
exports.BoundaryElementProvider = _visualEditing.BoundaryElementProvider;
exports.Box = _visualEditing.Box;
exports.Button = _visualEditing.Button;
exports.Card = _visualEditing.Card;
exports.Checkbox = _visualEditing.Checkbox;
exports.Code = _visualEditing.Code;
exports.ConditionalWrapper = _visualEditing.ConditionalWrapper;
exports.Container = _visualEditing.Container;
exports.ElementQuery = _visualEditing.ElementQuery;
exports.Flex = _visualEditing.Flex;
exports.Grid = _visualEditing.Grid;
exports.Heading = _visualEditing.Heading;
exports.Hotkeys = _visualEditing.Hotkeys;
exports.Inline = _visualEditing.Inline;
exports.KBD = _visualEditing.KBD;
exports.Label = _visualEditing.Label;
exports.Layer = _visualEditing.Layer;
exports.LayerProvider = _visualEditing.LayerProvider;
exports.Menu = _visualEditing.Menu;
exports.MenuDivider = _visualEditing.MenuDivider;
exports.MenuGroup = _visualEditing.MenuGroup;
exports.MenuItem = _visualEditing.MenuItem;
exports.Popover = _visualEditing.Popover;
exports.Portal = _visualEditing.Portal;
exports.PortalProvider = _visualEditing.PortalProvider;
exports.Radio = _visualEditing.Radio;
exports.Select = _visualEditing.Select;
exports.Spinner = _visualEditing.Spinner;
exports.SrOnly = _visualEditing.SrOnly;
exports.Stack = _visualEditing.Stack;
exports.Switch = _visualEditing.Switch;
exports.Tab = _visualEditing.Tab;
exports.TabList = _visualEditing.TabList;
exports.Text = _visualEditing.Text;
exports.TextArea = _visualEditing.TextArea;
exports.TextInput = _visualEditing.TextInput;
exports.ThemeColorProvider = _visualEditing.ThemeColorProvider;
exports.ThemeProvider = _visualEditing.ThemeProvider;
exports.Tooltip = _visualEditing.Tooltip;
exports.TooltipDelayGroupContext = _visualEditing.TooltipDelayGroupContext;
exports.TooltipDelayGroupProvider = _visualEditing.TooltipDelayGroupProvider;
exports.VirtualList = _visualEditing.VirtualList;
exports._ResizeObserver = _visualEditing._ResizeObserver;
exports._elementSizeObserver = _visualEditing._elementSizeObserver;
exports._fillCSSObject = _visualEditing._fillCSSObject;
exports._getArrayProp = _visualEditing._getArrayProp;
exports._getResponsiveSpace = _visualEditing._getResponsiveSpace;
exports._isEnterToClickElement = _visualEditing._isEnterToClickElement;
exports._isScrollable = _visualEditing._isScrollable;
exports._responsive = _visualEditing._responsive;
exports.containsOrEqualsElement = _visualEditing.containsOrEqualsElement;
exports.createColorTheme = _visualEditing.createColorTheme;
exports.hexToRgb = _visualEditing.hexToRgb;
exports.hslToRgb = _visualEditing.hslToRgb;
exports.isHTMLAnchorElement = _visualEditing.isHTMLAnchorElement;
exports.isHTMLButtonElement = _visualEditing.isHTMLButtonElement;
exports.isHTMLElement = _visualEditing.isHTMLElement;
exports.isHTMLInputElement = _visualEditing.isHTMLInputElement;
exports.isHTMLSelectElement = _visualEditing.isHTMLSelectElement;
exports.isHTMLTextAreaElement = _visualEditing.isHTMLTextAreaElement;
exports.multiply = _visualEditing.multiply;
exports.parseColor = _visualEditing.parseColor;
exports.rem = _visualEditing.rem;
exports.responsiveCodeFontStyle = _visualEditing.responsiveCodeFontStyle;
exports.responsiveHeadingFont = _visualEditing.responsiveHeadingFont;
exports.responsiveLabelFont = _visualEditing.responsiveLabelFont;
exports.responsiveTextAlignStyle = _visualEditing.responsiveTextAlignStyle;
exports.responsiveTextFont = _visualEditing.responsiveTextFont;
exports.rgbToHex = _visualEditing.rgbToHex;
exports.rgbToHsl = _visualEditing.rgbToHsl;
exports.rgba = _visualEditing.rgba;
exports.screen = _visualEditing.screen;
exports.studioTheme = _visualEditing.studioTheme;
exports.useArrayProp = _visualEditing.useArrayProp;
exports.useBoundaryElement = _visualEditing.useBoundaryElement;
exports.useClickOutsideEvent = _visualEditing.useClickOutsideEvent;
exports.useCustomValidity = _visualEditing.useCustomValidity;
exports.useElementSize = _visualEditing.useElementSize;
exports.useGlobalKeyDown = _visualEditing.useGlobalKeyDown;
exports.useLayer = _visualEditing.useLayer;
exports.useMatchMedia = _visualEditing.useMatchMedia;
exports.useMediaIndex = _visualEditing.useMediaIndex;
exports.usePortal = _visualEditing.usePortal;
exports.usePrefersDark = _visualEditing.usePrefersDark;
exports.usePrefersReducedMotion = _visualEditing.usePrefersReducedMotion;
exports.useRootTheme = _visualEditing.useRootTheme;
exports.useTheme = _visualEditing.useTheme;
exports.useTheme_v2 = _visualEditing.useTheme_v2;
exports.useTooltipDelayGroup = _visualEditing.useTooltipDelayGroup;
exports.Autocomplete = Autocomplete;
exports.Breadcrumbs = Breadcrumbs;
exports.CodeSkeleton = CodeSkeleton;
exports.Dialog = Dialog;
exports.DialogContext = DialogContext;
exports.DialogProvider = DialogProvider;
exports.ErrorBoundary = ErrorBoundary;
exports.HeadingSkeleton = HeadingSkeleton;
exports.LabelSkeleton = LabelSkeleton;
exports.MenuButton = MenuButton;
exports.Skeleton = Skeleton;
exports.TabPanel = TabPanel;
exports.TextSkeleton = TextSkeleton;
exports.Toast = Toast;
exports.ToastProvider = ToastProvider;
exports.Tree = Tree;
exports.TreeItem = TreeItem;
exports._hasFocus = _hasFocus;
exports._raf = _raf;
exports._raf2 = _raf2;
exports.attemptFocus = attemptFocus;
exports.focusFirstDescendant = focusFirstDescendant;
exports.focusLastDescendant = focusLastDescendant;
exports.isFocusable = isFocusable;
exports.useClickOutside = useClickOutside;
exports.useDialog = useDialog;
exports.useElementRect = useElementRect;
exports.useForwardedRef = useForwardedRef;
exports.useToast = useToast;
exports.useTree = useTree;
//# sourceMappingURL=index.js.map
