import { jsx, jsxs, Fragment as Fragment$1 } from "react/jsx-runtime";
import { c } from "react-compiler-runtime";
import { useTranslation, Translate, useDataset, useClient, usePerspective } from "sanity";
import { Spinner, rem, useTheme, Box, useClickOutsideEvent, Popover, Inline, Text, Card, Badge, Stack, Button, Code, Tooltip, Flex, Label, Grid, Select, TextInput, Hotkeys, useToast, Container, Heading } from "@sanity/ui";
import { useState, useEffect, useRef, PureComponent, createRef, Fragment, Component } from "react";
import { SplitPane } from "@rexxars/react-split-pane";
import { HelpCircleIcon, LinkIcon, DocumentSheetIcon, CopyIcon, ErrorOutlineIcon, StopIcon, PlayIcon } from "@sanity/icons";
import { isHotkey } from "is-hotkey-esm";
import debounce from "lodash/debounce.js";
import isEqual from "react-fast-compare";
import CodeMirror from "@uiw/react-codemirror";
import { closeBrackets } from "@codemirror/autocomplete";
import { history, defaultKeymap, historyKeymap } from "@codemirror/commands";
import { javascriptLanguage } from "@codemirror/lang-javascript";
import { indentOnInput, bracketMatching, syntaxHighlighting, defaultHighlightStyle, HighlightStyle } from "@codemirror/language";
import { highlightSelectionMatches } from "@codemirror/search";
import { lineNumbers, highlightActiveLine, highlightActiveLineGutter, highlightSpecialChars, drawSelection, keymap, EditorView } from "@codemirror/view";
import { tags } from "@lezer/highlight";
import { hues } from "@sanity/color";
import { styled, css } from "styled-components";
import { json2csv } from "json-2-csv";
import { ResizeObserver } from "@juggle/resize-observer";
import JSON5 from "json5";
import { visionLocaleNamespace } from "./index.esm.js";
import { JsonInspector } from "@rexxars/react-json-inspector";
import LRU from "quick-lru";
import { IntentLink } from "sanity/router";
const API_VERSIONS = ["v1", "vX", "v2021-03-25", "v2021-10-21", "v2022-03-07", `v${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}`], [DEFAULT_API_VERSION] = API_VERSIONS.slice(-1);
function DelayedSpinner(props) {
  const $ = c(5), [show, setShow] = useState(!1);
  let t0, t1;
  $[0] !== props.delay ? (t0 = () => {
    const timer = setTimeout(() => setShow(!0), props.delay || 500);
    return () => clearTimeout(timer);
  }, t1 = [props.delay], $[0] = props.delay, $[1] = t0, $[2] = t1) : (t0 = $[1], t1 = $[2]), useEffect(t0, t1);
  let t2;
  return $[3] !== show ? (t2 = show ? /* @__PURE__ */ jsx(Spinner, { muted: !0, size: 4 }) : null, $[3] = show, $[4] = t2) : t2 = $[4], t2;
}
const codemirrorExtensions = [[javascriptLanguage], lineNumbers(), highlightActiveLine(), highlightActiveLineGutter(), highlightSelectionMatches(), highlightSpecialChars(), indentOnInput(), bracketMatching(), closeBrackets(), history(), drawSelection(), syntaxHighlighting(defaultHighlightStyle, {
  fallback: !0
}), keymap.of([
  // Override the default keymap for Mod-Enter to not insert a new line, we have a custom event handler for executing queries
  {
    key: "Mod-Enter",
    run: () => !0
  },
  // Add the default keymap and history keymap
  defaultKeymap,
  historyKeymap
].flat().filter(Boolean))];
function useCodemirrorTheme(theme) {
  const $ = c(7);
  let t0, t1;
  $[0] !== theme ? (t1 = createTheme(theme), $[0] = theme, $[1] = t1) : t1 = $[1], t0 = t1;
  const cmTheme = t0;
  let t2, t3;
  $[2] !== theme ? (t3 = syntaxHighlighting(createHighlight(theme)), $[2] = theme, $[3] = t3) : t3 = $[3], t2 = t3;
  const cmHighlight = t2;
  let t4;
  return $[4] !== cmHighlight || $[5] !== cmTheme ? (t4 = [cmTheme, cmHighlight], $[4] = cmHighlight, $[5] = cmTheme, $[6] = t4) : t4 = $[6], t4;
}
function createTheme(theme) {
  const {
    color,
    fonts
  } = theme.sanity, card = color.card.enabled, cursor = hues.blue[color.dark ? 400 : 500].hex, selection = hues.gray[theme.sanity.color.dark ? 900 : 100].hex;
  return EditorView.theme({
    "&": {
      color: card.fg,
      backgroundColor: card.bg
    },
    ".cm-content": {
      caretColor: cursor
    },
    ".cm-editor": {
      fontFamily: fonts.code.family,
      fontSize: rem(fonts.code.sizes[1].fontSize),
      lineHeight: "inherit"
    },
    ".cm-cursor, .cm-dropCursor": {
      borderLeftColor: cursor
    },
    "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": {
      backgroundColor: selection
    },
    ".cm-panels": {
      backgroundColor: card.bg,
      color: card.fg
    },
    ".cm-panels.cm-panels-top": {
      borderBottom: `2px solid ${card.border}`
    },
    ".cm-panels.cm-panels-bottom": {
      borderTop: `2px solid ${card.border}`
    }
  }, {
    dark: color.dark
  });
}
function createHighlight(theme) {
  const c2 = theme.sanity.color.base, s = theme.sanity.color.syntax;
  return HighlightStyle.define([{
    tag: tags.keyword,
    color: s.keyword
  }, {
    tag: [tags.propertyName, tags.name, tags.deleted, tags.character, tags.macroName],
    color: s.property
  }, {
    tag: [tags.function(tags.variableName), tags.labelName],
    color: s.function
  }, {
    tag: [tags.color, tags.constant(tags.name), tags.standard(tags.name)],
    color: s.variable
  }, {
    tag: [tags.definition(tags.name), tags.separator],
    color: s.constant
  }, {
    tag: [tags.typeName, tags.className, tags.number, tags.changed, tags.annotation, tags.modifier, tags.self, tags.namespace],
    color: s.number
  }, {
    tag: [tags.operator, tags.operatorKeyword, tags.url, tags.escape, tags.regexp, tags.link, tags.special(tags.string)],
    color: s.operator
  }, {
    tag: [tags.meta, tags.comment],
    color: s.comment
  }, {
    tag: tags.strong,
    fontWeight: "bold"
  }, {
    tag: tags.emphasis,
    fontStyle: "italic"
  }, {
    tag: tags.strikethrough,
    textDecoration: "line-through"
  }, {
    tag: tags.heading,
    fontWeight: "bold",
    color: s.property
  }, {
    tag: [tags.atom, tags.bool, tags.special(tags.variableName)],
    color: s.boolean
  }, {
    tag: [tags.processingInstruction, tags.string, tags.inserted],
    color: s.string
  }, {
    tag: tags.invalid,
    color: c2.fg
  }]);
}
const EditorRoot = styled.div`
  width: 100%;
  box-sizing: border-box;
  height: 100%;
  overflow: hidden;
  overflow: clip;
  position: relative;
  display: flex;

  & .cm-theme {
    width: 100%;
  }

  & .cm-editor {
    height: 100%;

    font-size: 16px;
    line-height: 21px;
  }

  & .cm-line {
    padding-left: ${({
  theme
}) => rem(theme.sanity.space[3])};
  }

  & .cm-content {
    border-right-width: ${({
  theme
}) => rem(theme.sanity.space[4])} !important;
    padding-top: ${({
  theme
}) => rem(theme.sanity.space[5])};
  }
`;
function VisionCodeMirror(props) {
  const $ = c(3), sanityTheme = useTheme(), theme = useCodemirrorTheme(sanityTheme);
  let t0;
  return $[0] !== props || $[1] !== theme ? (t0 = /* @__PURE__ */ jsx(EditorRoot, { children: /* @__PURE__ */ jsx(CodeMirror, { basicSetup: !1, theme, extensions: codemirrorExtensions, ...props }) }), $[0] = props, $[1] = theme, $[2] = t0) : t0 = $[2], t0;
}
const SUPPORTED_PERSPECTIVES = ["pinnedRelease", "raw", "published", "drafts"], VIRTUAL_PERSPECTIVES = ["pinnedRelease"];
function isSupportedPerspective(p) {
  return SUPPORTED_PERSPECTIVES.includes(p);
}
function isVirtualPerspective(maybeVirtualPerspective) {
  return typeof maybeVirtualPerspective == "string" && VIRTUAL_PERSPECTIVES.includes(maybeVirtualPerspective);
}
function encodeQueryString(query, params = {}, options = {}) {
  const searchParams = new URLSearchParams();
  searchParams.set("query", query);
  for (const [key, value] of Object.entries(params))
    searchParams.set(`$${key}`, JSON.stringify(value));
  for (const [key, value] of Object.entries(options))
    value && searchParams.set(key, `${value}`);
  return `?${searchParams}`;
}
function getBlobUrl(content, mimeType) {
  return URL.createObjectURL(new Blob([content], {
    type: mimeType
  }));
}
function getMemoizedBlobUrlResolver(mimeType, stringEncoder) {
  return /* @__PURE__ */ (() => {
    let prevResult = "", prevContent = "";
    return (input) => {
      const content = stringEncoder(input);
      if (!(typeof content != "string" || content === ""))
        return content === prevContent || (prevContent = content, prevResult && URL.revokeObjectURL(prevResult), prevResult = getBlobUrl(content, mimeType)), prevResult;
    };
  })();
}
const getJsonBlobUrl = getMemoizedBlobUrlResolver("application/json", (input) => JSON.stringify(input, null, 2)), getCsvBlobUrl = getMemoizedBlobUrlResolver("text/csv", (input) => json2csv(Array.isArray(input) ? input : [input]).trim());
function isPlainObject(obj) {
  return !!obj && typeof obj == "object" && Object.prototype.toString.call(obj) === "[object Object]";
}
const hasLocalStorage = supportsLocalStorage(), keyPrefix = "sanityVision:";
function clearLocalStorage() {
  if (hasLocalStorage)
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      key?.startsWith(keyPrefix) && localStorage.removeItem(key);
    }
}
function getLocalStorage(namespace) {
  const storageKey = `${keyPrefix}${namespace}`;
  let loadedState = null;
  return {
    get,
    set,
    merge
  };
  function get(key, defaultVal) {
    const state = ensureState();
    return typeof state[key] > "u" ? defaultVal : state[key];
  }
  function set(key, value) {
    const state = ensureState();
    return state[key] = value, localStorage.setItem(storageKey, JSON.stringify(loadedState)), value;
  }
  function merge(props) {
    const state = {
      ...ensureState(),
      ...props
    };
    return localStorage.setItem(storageKey, JSON.stringify(state)), state;
  }
  function ensureState() {
    return loadedState === null && (loadedState = loadState()), loadedState;
  }
  function loadState() {
    if (!hasLocalStorage)
      return {};
    try {
      const stored = JSON.parse(localStorage.getItem(storageKey) || "{}");
      return isPlainObject(stored) ? stored : {};
    } catch {
      return {};
    }
  }
}
function supportsLocalStorage() {
  const mod = "lsCheck";
  try {
    return localStorage.setItem(mod, mod), localStorage.removeItem(mod), !0;
  } catch {
    return !1;
  }
}
function parseApiQueryString(qs) {
  const params = {}, options = {};
  for (const [key, value] of qs.entries()) {
    if (key[0] === "$") {
      params[key.slice(1)] = JSON.parse(value);
      continue;
    }
    if (key === "perspective") {
      options[key] = value;
      continue;
    }
  }
  return {
    query: qs.get("query") || "",
    params,
    options
  };
}
function prefixApiVersion(version) {
  return version[0] !== "v" && version !== "other" ? `v${version}` : version;
}
const RO = typeof document > "u" ? ResizeObserver : window.ResizeObserver;
function tryParseParams(val, t) {
  try {
    const parsed = val ? JSON5.parse(val) : {};
    return typeof parsed == "object" && parsed && !Array.isArray(parsed) ? parsed : {};
  } catch (err) {
    return err.message = `${t("params.error.params-invalid-json")}:

${err.message.replace("JSON5:", "")}`, err;
  }
}
function validateApiVersion(apiVersion) {
  const parseableApiVersion = apiVersion.replace(/^v/, "").trim().toUpperCase();
  return parseableApiVersion.length > 0 && (parseableApiVersion === "X" || parseableApiVersion === "1" || /^\d{4}-\d{2}-\d{2}$/.test(parseableApiVersion) && !isNaN(Date.parse(parseableApiVersion)));
}
const defaultValue = `{
  
}`;
function ParamsEditor(props) {
  const $ = c(20), {
    onChange,
    onPasteCapture
  } = props, {
    t
  } = useTranslation(visionLocaleNamespace);
  let t0;
  $[0] !== props.value || $[1] !== t ? (t0 = eventFromValue(props.value, t), $[0] = props.value, $[1] = t, $[2] = t0) : t0 = $[2];
  const {
    raw: value,
    error,
    parsed,
    valid
  } = t0, [isValid, setValid] = useState(valid), [init, setInit] = useState(!1);
  let t1, t2;
  $[3] !== error || $[4] !== init || $[5] !== isValid || $[6] !== onChange || $[7] !== parsed || $[8] !== value ? (t1 = () => {
    init || (onChange({
      parsed,
      raw: value,
      valid: isValid,
      error
    }), setInit(!0));
  }, t2 = [error, init, isValid, onChange, parsed, value], $[3] = error, $[4] = init, $[5] = isValid, $[6] = onChange, $[7] = parsed, $[8] = value, $[9] = t1, $[10] = t2) : (t1 = $[9], t2 = $[10]), useEffect(t1, t2);
  let t3;
  $[11] !== onChange || $[12] !== t ? (t3 = (newValue) => {
    const event = eventFromValue(newValue, t);
    setValid(event.valid), onChange(event);
  }, $[11] = onChange, $[12] = t, $[13] = t3) : t3 = $[13];
  const handleChangeRaw = t3;
  let t4, t5;
  $[14] !== handleChangeRaw ? (t5 = debounce(handleChangeRaw, 333), $[14] = handleChangeRaw, $[15] = t5) : t5 = $[15], t4 = t5;
  const handleChange = t4, t6 = props.value || defaultValue;
  let t7;
  return $[16] !== handleChange || $[17] !== onPasteCapture || $[18] !== t6 ? (t7 = /* @__PURE__ */ jsx(VisionCodeMirror, { value: t6, onChange: handleChange, onPasteCapture }), $[16] = handleChange, $[17] = onPasteCapture, $[18] = t6, $[19] = t7) : t7 = $[19], t7;
}
function eventFromValue(value, t) {
  const parsedParams = tryParseParams(value, t), params = parsedParams instanceof Error ? {} : parsedParams, validationError = parsedParams instanceof Error ? parsedParams.message : void 0;
  return {
    parsed: params,
    raw: value,
    valid: !validationError,
    error: validationError
  };
}
const PerspectivePopoverContent = styled(Box)`
  /* This limits the width of the popover content */
  max-width: 240px;
`, PerspectivePopoverLink = styled.a`
  cursor: pointer;
  margin-right: auto;
`, Dot = styled.div`
  width: 4px;
  height: 4px;
  border-radius: 3px;
  box-shadow: 0 0 0 1px var(--card-bg-color);
  background-color: ${({
  tone
}) => `var(--card-badge-${tone}-dot-color)`};
`;
function PerspectivePopover() {
  const $ = c(39), [open, setOpen] = useState(!1), buttonRef = useRef(null), popoverRef = useRef(null);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => setOpen(_temp$2), $[0] = t0) : t0 = $[0];
  const handleClick = t0, {
    t
  } = useTranslation(visionLocaleNamespace);
  let t1, t2;
  $[1] === Symbol.for("react.memo_cache_sentinel") ? (t1 = () => setOpen(!1), t2 = () => [buttonRef.current, popoverRef.current], $[1] = t1, $[2] = t2) : (t1 = $[1], t2 = $[2]), useClickOutsideEvent(t1, t2);
  let t3;
  $[3] !== t ? (t3 = t("settings.perspectives.title"), $[3] = t, $[4] = t3) : t3 = $[4];
  let t4;
  $[5] !== t3 ? (t4 = /* @__PURE__ */ jsx(Inline, { space: 2, children: /* @__PURE__ */ jsx(Text, { weight: "medium", children: t3 }) }), $[5] = t3, $[6] = t4) : t4 = $[6];
  let t5;
  $[7] !== t ? (t5 = t("settings.perspectives.description"), $[7] = t, $[8] = t5) : t5 = $[8];
  let t6;
  $[9] !== t5 ? (t6 = /* @__PURE__ */ jsx(Card, { children: /* @__PURE__ */ jsx(Text, { muted: !0, children: t5 }) }), $[9] = t5, $[10] = t6) : t6 = $[10];
  let t7;
  $[11] !== t ? (t7 = t("label.new"), $[11] = t, $[12] = t7) : t7 = $[12];
  let t8;
  $[13] !== t7 ? (t8 = /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Badge, { tone: "primary", children: t7 }) }), $[13] = t7, $[14] = t8) : t8 = $[14];
  let t9;
  $[15] !== t ? (t9 = /* @__PURE__ */ jsx(Text, { muted: !0, children: /* @__PURE__ */ jsx(Translate, { t, i18nKey: "settings.perspective.preview-drafts-renamed-to-drafts.description" }) }), $[15] = t, $[16] = t9) : t9 = $[16];
  let t10;
  $[17] !== t8 || $[18] !== t9 ? (t10 = /* @__PURE__ */ jsx(Card, { children: /* @__PURE__ */ jsxs(Stack, { space: 2, children: [
    t8,
    t9
  ] }) }), $[17] = t8, $[18] = t9, $[19] = t10) : t10 = $[19];
  let t11;
  $[20] !== t ? (t11 = null, $[20] = t, $[21] = t11) : t11 = $[21];
  let t12;
  $[22] !== t ? (t12 = t("settings.perspectives.action.docs-link"), $[22] = t, $[23] = t12) : t12 = $[23];
  let t13;
  $[24] !== t12 ? (t13 = /* @__PURE__ */ jsx(Card, { children: /* @__PURE__ */ jsx(Text, { children: /* @__PURE__ */ jsxs(PerspectivePopoverLink, { href: "https://sanity.io/docs/perspectives", target: "_blank", children: [
    t12,
    " \u2192"
  ] }) }) }), $[24] = t12, $[25] = t13) : t13 = $[25];
  let t14;
  $[26] !== t10 || $[27] !== t11 || $[28] !== t13 || $[29] !== t4 || $[30] !== t6 ? (t14 = /* @__PURE__ */ jsx(PerspectivePopoverContent, { children: /* @__PURE__ */ jsxs(Stack, { space: 4, children: [
    t4,
    t6,
    t10,
    t11,
    t13
  ] }) }), $[26] = t10, $[27] = t11, $[28] = t13, $[29] = t4, $[30] = t6, $[31] = t14) : t14 = $[31];
  let t15;
  $[32] === Symbol.for("react.memo_cache_sentinel") ? (t15 = /* @__PURE__ */ jsx(Dot, { tone: "primary" }), $[32] = t15) : t15 = $[32];
  let t16;
  $[33] !== open ? (t16 = /* @__PURE__ */ jsx(Button, { icon: HelpCircleIcon, mode: "bleed", padding: 2, paddingRight: 1, tone: "primary", fontSize: 1, ref: buttonRef, onClick: handleClick, selected: open, children: t15 }), $[33] = open, $[34] = t16) : t16 = $[34];
  let t17;
  return $[35] !== open || $[36] !== t14 || $[37] !== t16 ? (t17 = /* @__PURE__ */ jsx(Popover, { content: t14, placement: "bottom-start", portal: !0, padding: 3, ref: popoverRef, open, children: t16 }), $[35] = open, $[36] = t14, $[37] = t16, $[38] = t17) : t17 = $[38], t17;
}
function _temp$2(o) {
  return !o;
}
const ErrorCode = styled(Code)`
  color: ${({
  theme
}) => theme.sanity.color.muted.critical.enabled.fg};
`;
function QueryErrorDetails(t0) {
  const $ = c(7), {
    error
  } = t0, {
    t
  } = useTranslation(visionLocaleNamespace);
  if (!("details" in error))
    return null;
  const details = {
    ...error.details,
    ...mapToLegacyDetails(error.details)
  };
  if (!details.line)
    return null;
  const t1 = `${details.line}
${dashLine(details.column, details.columnEnd)}`;
  let t2;
  $[0] !== t1 ? (t2 = /* @__PURE__ */ jsx(ErrorCode, { size: 1, children: t1 }), $[0] = t1, $[1] = t2) : t2 = $[1];
  const t3 = `${t("query.error.line")}:   ${details.lineNumber}
${t("query.error.column")}: ${details.column}`;
  let t4;
  $[2] !== t3 ? (t4 = /* @__PURE__ */ jsx(Box, { marginTop: 4, children: /* @__PURE__ */ jsx(ErrorCode, { size: 1, children: t3 }) }), $[2] = t3, $[3] = t4) : t4 = $[3];
  let t5;
  return $[4] !== t2 || $[5] !== t4 ? (t5 = /* @__PURE__ */ jsxs("div", { children: [
    t2,
    t4
  ] }), $[4] = t2, $[5] = t4, $[6] = t5) : t5 = $[6], t5;
}
function mapToLegacyDetails(details) {
  if (!details || typeof details.query != "string" || typeof details.start != "number")
    return {};
  const {
    query,
    start,
    end
  } = details, lineStart = query.slice(0, start).lastIndexOf(`
`) + 1, lineNumber = (query.slice(0, lineStart).match(/\n/g) || []).length, line = query.slice(lineStart, query.indexOf(`
`, lineStart)), column = start - lineStart, columnEnd = typeof end == "number" ? end - lineStart : void 0;
  return {
    line,
    lineNumber,
    column,
    columnEnd
  };
}
function dashLine(column, columnEnd) {
  const line = "-".repeat(column), hats = "^".repeat(columnEnd ? columnEnd - column : 1);
  return `${line}${hats}`;
}
function QueryErrorDialog(props) {
  const $ = c(7);
  let t0;
  $[0] !== props.error.message ? (t0 = /* @__PURE__ */ jsx(ErrorCode, { size: 1, children: props.error.message }), $[0] = props.error.message, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] !== props.error ? (t1 = /* @__PURE__ */ jsx(QueryErrorDetails, { error: props.error }), $[2] = props.error, $[3] = t1) : t1 = $[3];
  let t2;
  return $[4] !== t0 || $[5] !== t1 ? (t2 = /* @__PURE__ */ jsxs(Stack, { space: 5, marginTop: 2, children: [
    t0,
    t1
  ] }), $[4] = t0, $[5] = t1, $[6] = t2) : t2 = $[6], t2;
}
const ResultViewWrapper = styled.div(({
  theme
}) => {
  const {
    color,
    fonts,
    space
  } = theme.sanity;
  return css`
    & .json-inspector,
    & .json-inspector .json-inspector__selection {
      font-family: ${fonts.code.family};
      font-size: ${fonts.code.sizes[2].fontSize}px;
      line-height: ${fonts.code.sizes[2].lineHeight}px;
      color: var(--card-code-fg-color);
    }

    & .json-inspector .json-inspector__leaf {
      padding-left: ${rem(space[4])};
    }

    & .json-inspector .json-inspector__leaf.json-inspector__leaf_root {
      padding-top: ${rem(space[0])};
      padding-left: 0;
    }

    & .json-inspector > .json-inspector__leaf_root > .json-inspector__line > .json-inspector__key {
      display: none;
    }

    & .json-inspector .json-inspector__line {
      display: block;
      position: relative;
      cursor: default;
    }

    & .json-inspector .json-inspector__line::after {
      content: '';
      position: absolute;
      top: 0;
      left: -200px;
      right: -50px;
      bottom: 0;
      z-index: -1;
      pointer-events: none;
    }

    & .json-inspector .json-inspector__line:hover::after {
      background: var(--card-code-bg-color);
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line {
      cursor: pointer;
    }

    & .json-inspector .json-inspector__leaf_composite > .json-inspector__line::before {
      content: '▸ ';
      margin-left: calc(0px - ${rem(space[4])});
      font-size: ${fonts.code.sizes[2].fontSize}px;
      line-height: ${fonts.code.sizes[2].lineHeight}px;
    }

    &
      .json-inspector
      .json-inspector__leaf_expanded.json-inspector__leaf_composite
      > .json-inspector__line::before {
      content: '▾ ';
      font-size: ${fonts.code.sizes[2].fontSize}px;
      line-height: ${fonts.code.sizes[2].lineHeight}px;
    }

    & .json-inspector .json-inspector__radio,
    & .json-inspector .json-inspector__flatpath {
      display: none;
    }

    & .json-inspector .json-inspector__value {
      margin-left: ${rem(space[4] / 2)};
    }

    &
      .json-inspector
      > .json-inspector__leaf_root
      > .json-inspector__line
      > .json-inspector__key
      + .json-inspector__value {
      margin: 0;
    }

    & .json-inspector .json-inspector__key {
      color: ${color.syntax.property};
    }

    & .json-inspector .json-inspector__value_helper,
    & .json-inspector .json-inspector__value_null {
      color: ${color.syntax.constant};
    }

    & .json-inspector .json-inspector__not-found {
      padding-top: ${rem(space[2])};
    }

    & .json-inspector .json-inspector__value_string {
      color: ${color.syntax.string};
      word-break: break-word;
    }

    & .json-inspector .json-inspector__value_boolean {
      color: ${color.syntax.boolean};
    }

    & .json-inspector .json-inspector__value_number {
      color: ${color.syntax.number};
    }

    & .json-inspector .json-inspector__show-original {
      display: inline-block;
      padding: 0 6px;
      cursor: pointer;
    }

    & .json-inspector .json-inspector__show-original:hover {
      color: inherit;
    }

    & .json-inspector .json-inspector__show-original::before {
      content: '↔';
    }

    & .json-inspector .json-inspector__show-original:hover::after {
      content: ' expand';
    }
  `;
}), lru = new LRU({
  maxSize: 5e4
});
function ResultView(props) {
  const $ = c(7), {
    data,
    datasetName
  } = props, workspaceDataset = useDataset();
  if (isRecord(data) || Array.isArray(data)) {
    const t02 = workspaceDataset === datasetName ? DocumentEditLabel : void 0;
    let t12;
    return $[0] !== data || $[1] !== t02 ? (t12 = /* @__PURE__ */ jsx(ResultViewWrapper, { children: /* @__PURE__ */ jsx(JsonInspector, { data, search: !1, isExpanded, onClick: toggleExpanded, interactiveLabel: t02 }) }), $[0] = data, $[1] = t02, $[2] = t12) : t12 = $[2], t12;
  }
  let t0;
  $[3] !== data ? (t0 = JSON.stringify(data), $[3] = data, $[4] = t0) : t0 = $[4];
  let t1;
  return $[5] !== t0 ? (t1 = /* @__PURE__ */ jsx(Code, { language: "json", children: t0 }), $[5] = t0, $[6] = t1) : t1 = $[6], t1;
}
function DocumentEditLabel(props) {
  const $ = c(5);
  if (props.isKey || !props.keypath.endsWith("_id") && !props.keypath.endsWith("_ref"))
    return null;
  let t0;
  $[0] !== props.value ? (t0 = {
    id: props.value
  }, $[0] = props.value, $[1] = t0) : t0 = $[1];
  let t1;
  $[2] === Symbol.for("react.memo_cache_sentinel") ? (t1 = /* @__PURE__ */ jsx(LinkIcon, {}), $[2] = t1) : t1 = $[2];
  let t2;
  return $[3] !== t0 ? (t2 = /* @__PURE__ */ jsx(IntentLink, { intent: "edit", params: t0, children: t1 }), $[3] = t0, $[4] = t2) : t2 = $[4], t2;
}
function isExpanded(keyPath, value) {
  const cached = lru.get(keyPath);
  if (typeof cached == "boolean")
    return cached;
  const segments = keyPath.split(".", 4);
  return segments.length === 4 ? !1 : Array.isArray(value) ? !0 : isRecord(value) && !segments.some((key) => isArrayKeyOverLimit(key));
}
function toggleExpanded(event) {
  const {
    path
  } = event, current = lru.get(path);
  current !== void 0 && lru.set(path, !current);
}
function isRecord(value) {
  return value !== null && typeof value == "object" && !Array.isArray(value);
}
const numeric = /^\d+$/;
function isArrayKeyOverLimit(segment, limit = 10) {
  return numeric.test(segment) && parseInt(segment, 10) > limit;
}
function preventSave(evt) {
  return evt.preventDefault();
}
function SaveCsvButton(t0) {
  const $ = c(9), {
    blobUrl
  } = t0, {
    t
  } = useTranslation(visionLocaleNamespace), isDisabled = !blobUrl, t1 = isDisabled ? void 0 : "query-result.csv", t2 = isDisabled ? preventSave : void 0;
  let t3;
  $[0] !== blobUrl || $[1] !== isDisabled || $[2] !== t1 || $[3] !== t2 ? (t3 = /* @__PURE__ */ jsx(Button, { as: "a", disabled: isDisabled, download: t1, href: blobUrl, icon: DocumentSheetIcon, mode: "ghost", onClick: t2, text: "CSV", tone: "default" }), $[0] = blobUrl, $[1] = isDisabled, $[2] = t1, $[3] = t2, $[4] = t3) : t3 = $[4];
  const button = t3;
  let t4;
  return $[5] !== button || $[6] !== isDisabled || $[7] !== t ? (t4 = isDisabled ? /* @__PURE__ */ jsx(Tooltip, { content: t("result.save-result-as-csv.not-csv-encodable"), placement: "top", children: button }) : button, $[5] = button, $[6] = isDisabled, $[7] = t, $[8] = t4) : t4 = $[8], t4;
}
function SaveJsonButton(t0) {
  const $ = c(2), {
    blobUrl
  } = t0;
  let t1;
  return $[0] !== blobUrl ? (t1 = /* @__PURE__ */ jsx(Button, { as: "a", download: "query-result.json", href: blobUrl, icon: DocumentSheetIcon, mode: "ghost", text: "JSON", tone: "default" }), $[0] = blobUrl, $[1] = t1) : t1 = $[1], t1;
}
const Root = styled(Flex)`
  .sidebarPanes .Pane {
    overflow-y: auto;
    overflow-x: hidden;
  }

  & .Resizer {
    background: var(--card-border-color);
    opacity: 1;
    z-index: 1;
    box-sizing: border-box;
    background-clip: padding-box;
    border: solid transparent;
  }

  & .Resizer:hover {
    border-color: var(--card-shadow-ambient-color);
  }

  & .Resizer.horizontal {
    height: 11px;
    margin: -5px 0;
    border-width: 5px 0;
    cursor: row-resize;
    width: 100%;
    z-index: 4;
  }

  & .Resizer.vertical {
    width: 11px;
    margin: 0 -5px;
    border-width: 0 5px;
    cursor: col-resize;
    z-index: 2; /* To prevent the resizer from being hidden behind CodeMirror scroll area */
  }

  .Resizer.disabled {
    cursor: not-allowed;
  }

  .Resizer.disabled:hover {
    border-color: transparent;
  }
`;
Root.displayName = "Root";
const Header = styled(Card)`
  border-bottom: 1px solid var(--card-border-color);
`, StyledLabel = styled(Label)`
  flex: 1;
`, SplitpaneContainer = styled(Box)`
  position: relative;
`, QueryCopyLink = styled.a`
  cursor: pointer;
  margin-right: auto;
`, InputBackgroundContainer = styled(Box)`
  position: absolute;
  top: 1rem;
  left: 0;
  padding: 0;
  margin: 0;
  z-index: 10;
  right: 0;

  ${StyledLabel} {
    user-select: none;
  }
`, InputBackgroundContainerLeft = styled(InputBackgroundContainer)`
  // This is so its aligned with the gutters of CodeMirror
  left: 33px;
`, InputContainer = styled(Card)`
  width: 100%;
  height: 100%;
  position: relative;
  flex-direction: column;
`, ResultOuterContainer = styled(Flex)`
  height: 100%;
`, ResultInnerContainer = styled(Box)`
  position: relative;
`, ResultContainer = styled(Card)`
  height: 100%;
  width: 100%;
  position: absolute;
  max-width: 100%;

  ${({
  $isInvalid
}) => $isInvalid && css`
      &:after {
        background-color: var(--card-bg-color);
        content: '';
        position: absolute;
        top: 0;
        bottom: 0;
        left: 0;
        width: 100%;
      }
    `}
`, Result = styled(Box)`
  position: relative;
  width: 100%;
  height: 100%;
  z-index: 20;
`, ResultFooter = styled(Flex)`
  border-top: 1px solid var(--card-border-color);
`, TimingsCard = styled(Card)`
  position: relative;
`;
styled(Box)`
  width: 100%;
  height: 100%;
`;
const TimingsTextContainer = styled(Flex)`
  height: 100%;
  min-height: ${({
  theme
}) => rem(theme.sanity.space[3] * 2 + theme.sanity.fonts.text.sizes[2].lineHeight - theme.sanity.fonts.text.sizes[2].ascenderHeight - theme.sanity.fonts.text.sizes[2].descenderHeight)};
`, DownloadsCard = styled(Card)`
  position: relative;
`, SaveResultLabel = styled(Text)`
  transform: initial;
  &:before,
  &:after {
    content: none;
  }
  > span {
    display: flex !important;
    gap: ${({
  theme
}) => rem(theme.sanity.space[3])};
    align-items: center;
  }
`, ControlsContainer = styled(Box)`
  border-top: 1px solid var(--card-border-color);
`;
function nodeContains(node, other) {
  return !node || !other ? !1 : node === other || !!(node.compareDocumentPosition(other) & 16);
}
const sanityUrl = /\.(?:api|apicdn)\.sanity\.io\/(vX|v1|v\d{4}-\d\d-\d\d)\/.*?(?:query|listen)\/(.*?)\?(.*)/, isRunHotkey = (event) => isHotkey("ctrl+enter", event) || isHotkey("mod+enter", event);
function narrowBreakpoint() {
  return typeof window < "u" && window.innerWidth > 600;
}
function calculatePaneSizeOptions(rootHeight) {
  return {
    defaultSize: rootHeight / (narrowBreakpoint() ? 2 : 1),
    size: rootHeight > 550 ? void 0 : rootHeight * 0.4,
    allowResize: rootHeight > 550,
    minSize: Math.min(170, Math.max(170, rootHeight / 2)),
    maxSize: rootHeight > 650 ? rootHeight * 0.7 : rootHeight * 0.6
  };
}
class VisionGui extends PureComponent {
  constructor(props) {
    super(props);
    const {
      client,
      datasets,
      config
    } = props;
    this._localStorage = getLocalStorage(client.config().projectId || "default");
    const defaultDataset = config.defaultDataset || client.config().dataset || datasets[0], defaultApiVersion = prefixApiVersion(`${config.defaultApiVersion}`);
    let dataset = this._localStorage.get("dataset", defaultDataset), apiVersion = this._localStorage.get("apiVersion", defaultApiVersion), lastQuery = this._localStorage.get("query", ""), lastParams = this._localStorage.get("params", `{
  
}`);
    const customApiVersion = API_VERSIONS.includes(apiVersion) ? !1 : apiVersion, perspective = this._localStorage.get("perspective", void 0);
    datasets.includes(dataset) || (dataset = datasets.includes(defaultDataset) ? defaultDataset : datasets[0]), API_VERSIONS.includes(apiVersion) || (apiVersion = DEFAULT_API_VERSION), typeof lastQuery != "string" && (lastQuery = ""), typeof lastParams != "string" && (lastParams = `{
  
}`), this._visionRoot = createRef(), this._operationUrlElement = createRef(), this._queryEditorContainer = createRef(), this._paramsEditorContainer = createRef(), this._customApiVersionElement = createRef(), this._client = props.client.withConfig({
      apiVersion: customApiVersion || apiVersion,
      dataset,
      perspective: getActivePerspective({
        visionPerspective: perspective,
        pinnedPerspective: this.props.pinnedPerspective
      }),
      allowReconfigure: !0
    });
    const bodyHeight = typeof window < "u" && typeof document < "u" ? document.body.getBoundingClientRect().height - 60 : 0, params = lastParams ? tryParseParams(lastParams, this.props.t) : void 0;
    this.state = {
      // Selected options
      dataset,
      apiVersion,
      customApiVersion,
      perspective,
      // Selected options validation state
      isValidApiVersion: customApiVersion ? validateApiVersion(customApiVersion) : !1,
      // Inputs
      query: lastQuery,
      rawParams: lastParams,
      // Parsed input
      params,
      hasValidParams: !(params instanceof Error),
      // Query/listen results
      listenMutations: [],
      // Operation state
      queryInProgress: !1,
      listenInProgress: !1,
      // UI drawing state
      paneSizeOptions: calculatePaneSizeOptions(bodyHeight)
    }, this.handleChangeDataset = this.handleChangeDataset.bind(this), this.handleChangeApiVersion = this.handleChangeApiVersion.bind(this), this.handleCustomApiVersionChange = this.handleCustomApiVersionChange.bind(this), this.handleChangePerspective = this.handleChangePerspective.bind(this), this.handleListenExecution = this.handleListenExecution.bind(this), this.handleListenerEvent = this.handleListenerEvent.bind(this), this.handleQueryExecution = this.handleQueryExecution.bind(this), this.handleQueryChange = debounce(this.handleQueryChange, 300).bind(this), this.handleParamsChange = this.handleParamsChange.bind(this), this.handleCopyUrl = this.handleCopyUrl.bind(this), this.handlePaste = this.handlePaste.bind(this), this.handleKeyDown = this.handleKeyDown.bind(this), this.handleResize = this.handleResize.bind(this), this.handleOnPasteCapture = this.handleOnPasteCapture.bind(this), this.setPerspective = this.setPerspective.bind(this);
  }
  componentDidMount() {
    window.document.addEventListener("paste", this.handlePaste), window.document.addEventListener("keydown", this.handleKeyDown), this.handleResizeListen();
  }
  componentWillUnmount() {
    this.cancelQuery(), this.cancelListener(), this.cancelEventListener(), this.cancelResizeListener();
  }
  componentDidUpdate(prevProps) {
    hasPinnedPerspectiveChanged(prevProps.pinnedPerspective, this.props.pinnedPerspective) && (hasPinnedPerspective(this.props.pinnedPerspective) ? this.setPerspective("pinnedRelease") : this.setPerspective(void 0));
  }
  handleResizeListen() {
    this._visionRoot.current && (this._resizeListener = new RO(this.handleResize), this._resizeListener.observe(this._visionRoot.current));
  }
  handleResize(entries) {
    const entry = entries?.[0];
    this.setState((prevState) => ({
      ...prevState,
      paneSizeOptions: calculatePaneSizeOptions(entry.contentRect.height)
    }));
  }
  cancelResizeListener() {
    this._resizeListener && this._resizeListener.disconnect();
  }
  handlePaste(evt, stopPropagation = !1) {
    if (!evt?.clipboardData)
      return;
    const match = evt.clipboardData.getData("text/plain").match(sanityUrl);
    if (!match)
      return;
    const [, usedApiVersion, usedDataset, urlQuery] = match;
    let parts;
    try {
      const qs = new URLSearchParams(urlQuery);
      parts = parseApiQueryString(qs);
    } catch (err) {
      console.warn("Error while trying to parse API URL: ", err.message);
      return;
    }
    let apiVersion, customApiVersion;
    validateApiVersion(usedApiVersion) && (API_VERSIONS.includes(usedApiVersion) ? (apiVersion = usedApiVersion, customApiVersion = !1) : customApiVersion = usedApiVersion);
    const perspective = isSupportedPerspective(parts.options.perspective) && !isVirtualPerspective(parts.options.perspective) ? parts.options.perspective : void 0;
    perspective && (!isSupportedPerspective(parts.options.perspective) || isVirtualPerspective(parts.options.perspective)) && this.props.toast.push({
      closable: !0,
      id: "vision-paste-unsupported-perspective",
      status: "warning",
      title: 'Perspective in pasted url is currently not supported. Falling back to "raw"'
    }), evt.preventDefault(), stopPropagation && evt.stopPropagation(), this.setState((prevState) => ({
      dataset: this.props.datasets.includes(usedDataset) ? usedDataset : prevState.dataset,
      query: parts.query,
      params: parts.params,
      rawParams: JSON.stringify(parts.params, null, 2),
      apiVersion: typeof apiVersion > "u" ? prevState.apiVersion : apiVersion,
      customApiVersion: typeof customApiVersion > "u" ? prevState.customApiVersion : customApiVersion,
      perspective: typeof perspective > "u" ? prevState.perspective : perspective
    }), () => {
      this._localStorage.merge({
        query: this.state.query,
        params: this.state.rawParams,
        dataset: this.state.dataset,
        apiVersion: customApiVersion || apiVersion,
        perspective: this.state.perspective
      }), this._client.config({
        dataset: this.state.dataset,
        apiVersion: customApiVersion || apiVersion,
        perspective: getActivePerspective({
          visionPerspective: this.state.perspective,
          pinnedPerspective: this.props.pinnedPerspective
        })
      }), this.handleQueryExecution(), this.props.toast.push({
        closable: !0,
        id: "vision-paste",
        status: "info",
        title: "Parsed URL to query"
      });
    });
  }
  handleOnPasteCapture(ev) {
    this.handlePaste(ev, !0);
  }
  cancelQuery() {
    this._querySubscription && (this._querySubscription.unsubscribe(), this._querySubscription = void 0);
  }
  cancelListener() {
    this._listenSubscription && (this._listenSubscription.unsubscribe(), this._listenSubscription = void 0);
  }
  cancelEventListener() {
    window.removeEventListener("keydown", this.handleKeyDown);
  }
  handleChangeDataset(evt) {
    const dataset = evt.target.value;
    this._localStorage.set("dataset", dataset), this.setState({
      dataset
    }), this._client.config({
      dataset
    }), this.handleQueryExecution();
  }
  handleChangeApiVersion(evt) {
    const apiVersion = evt.target.value;
    if (apiVersion?.toLowerCase() === "other") {
      this.setState({
        customApiVersion: "v"
      }, () => {
        this._customApiVersionElement.current?.focus();
      });
      return;
    }
    this.setState({
      apiVersion,
      customApiVersion: !1
    }, () => {
      this._localStorage.set("apiVersion", this.state.apiVersion), this._client.config({
        apiVersion: this.state.apiVersion
      }), this.handleQueryExecution();
    });
  }
  handleCustomApiVersionChange(evt) {
    const customApiVersion = evt.target.value || "", isValidApiVersion = validateApiVersion(customApiVersion);
    this.setState((prevState) => ({
      apiVersion: isValidApiVersion ? customApiVersion : prevState.apiVersion,
      customApiVersion: customApiVersion || "v",
      isValidApiVersion
    }), () => {
      !this.state.isValidApiVersion || typeof this.state.customApiVersion != "string" || (this._localStorage.set("apiVersion", this.state.customApiVersion), this._client.config({
        apiVersion: this.state.customApiVersion
      }));
    });
  }
  handleChangePerspective(evt) {
    const perspective = evt.target.value;
    this.setPerspective(perspective === "default" ? void 0 : perspective);
  }
  setPerspective(perspective) {
    perspective !== void 0 && !isSupportedPerspective(perspective) || this.setState({
      perspective
    }, () => {
      this._localStorage.set("perspective", this.state.perspective), this._client.config({
        perspective: getActivePerspective({
          visionPerspective: this.state.perspective,
          pinnedPerspective: this.props.pinnedPerspective
        })
      }), this.handleQueryExecution();
    });
  }
  handleListenerEvent(evt) {
    if (evt.type !== "mutation") {
      this.props.toast.push({
        closable: !0,
        id: "vision-listen",
        status: "success",
        title: "Listening for mutations\u2026"
      });
      return;
    }
    this.setState(({
      listenMutations
    }) => ({
      listenMutations: listenMutations.length === 50 ? [evt, ...listenMutations.slice(0, 49)] : [evt, ...listenMutations]
    }));
  }
  handleKeyDown(event) {
    const {
      hasValidParams
    } = this.state, isWithinRoot = this._visionRoot.current && nodeContains(this._visionRoot.current, event.target);
    isRunHotkey(event) && isWithinRoot && hasValidParams && (this.handleQueryExecution(), event.preventDefault(), event.stopPropagation());
  }
  ensureSelectedApiVersion() {
    const {
      apiVersion,
      customApiVersion
    } = this.state, wantedApiVersion = customApiVersion || apiVersion;
    this._client.config().apiVersion !== wantedApiVersion && this._client.config({
      apiVersion: wantedApiVersion
    });
  }
  handleListenExecution() {
    const {
      query,
      params,
      rawParams,
      listenInProgress
    } = this.state;
    if (listenInProgress) {
      this.cancelListener(), this.setState({
        listenInProgress: !1
      });
      return;
    }
    this.ensureSelectedApiVersion();
    const paramsError = params instanceof Error ? params : void 0, encodeParams = params instanceof Error ? {} : params || {}, url = this._client.getDataUrl("listen", encodeQueryString(query, encodeParams, {})), shouldExecute = !paramsError && query.trim().length > 0;
    this._localStorage.set("query", query), this._localStorage.set("params", rawParams), this.cancelQuery(), this.setState({
      url,
      listenMutations: [],
      queryInProgress: !1,
      queryResult: void 0,
      listenInProgress: shouldExecute,
      error: paramsError,
      queryTime: void 0,
      e2eTime: void 0
    }), shouldExecute && (this._listenSubscription = this._client.listen(query, params, {
      events: ["mutation", "welcome"]
    }).subscribe({
      next: this.handleListenerEvent,
      error: (error) => this.setState({
        error,
        query,
        listenInProgress: !1
      })
    }));
  }
  handleQueryExecution() {
    const {
      query,
      params,
      rawParams,
      queryInProgress
    } = this.state;
    if (queryInProgress)
      return this.cancelQuery(), this.cancelListener(), this.setState({
        queryInProgress: !1
      }), !0;
    const paramsError = params instanceof Error && params;
    if (this._localStorage.set("query", query), this._localStorage.set("params", rawParams), this.cancelListener(), this.setState({
      queryInProgress: !paramsError && !!query,
      listenInProgress: !1,
      listenMutations: [],
      error: paramsError || void 0,
      queryResult: void 0,
      queryTime: void 0,
      e2eTime: void 0
    }), !query || paramsError)
      return !0;
    this.ensureSelectedApiVersion();
    const urlQueryOpts = {};
    this.state.perspective && (urlQueryOpts.perspective = getActivePerspective({
      visionPerspective: this.state.perspective,
      pinnedPerspective: this.props.pinnedPerspective
    }) ?? []);
    const url = this._client.getUrl(this._client.getDataUrl("query", encodeQueryString(query, params, urlQueryOpts)));
    this.setState({
      url
    });
    const queryStart = Date.now();
    return this._querySubscription = this._client.observable.fetch(query, params, {
      filterResponse: !1,
      tag: "vision"
    }).subscribe({
      next: (res) => {
        this.setState({
          queryTime: res.ms,
          e2eTime: Date.now() - queryStart,
          queryResult: res.result,
          queryInProgress: !1,
          error: void 0
        });
      },
      error: (error) => {
        this.setState({
          error,
          query,
          queryInProgress: !1
        });
      }
    }), !0;
  }
  handleQueryChange(query) {
    this.setState({
      query
    });
  }
  handleParamsChange({
    raw,
    parsed,
    valid,
    error
  }) {
    this.setState({
      rawParams: raw,
      params: parsed,
      hasValidParams: valid,
      paramsError: error
    }, () => this._localStorage.set("params", raw));
  }
  handleCopyUrl() {
    const el = this._operationUrlElement.current;
    if (el)
      try {
        el.select(), document.execCommand("copy"), this.props.toast.push({
          closable: !0,
          title: "Copied to clipboard",
          status: "info",
          id: "vision-copy"
        });
      } catch {
        console.error("Unable to copy to clipboard :(");
      }
  }
  render() {
    const {
      datasets,
      t,
      pinnedPerspective
    } = this.props, {
      apiVersion,
      customApiVersion,
      dataset,
      e2eTime,
      error,
      hasValidParams,
      isValidApiVersion,
      listenInProgress,
      listenMutations,
      paneSizeOptions,
      paramsError,
      perspective,
      query,
      queryInProgress,
      queryResult,
      queryTime,
      rawParams,
      url
    } = this.state, hasResult = !error && !queryInProgress && typeof queryResult < "u", jsonUrl = hasResult ? getJsonBlobUrl(queryResult) : "", csvUrl = hasResult ? getCsvBlobUrl(queryResult) : "";
    return /* @__PURE__ */ jsxs(Root, { direction: "column", height: "fill", ref: this._visionRoot, sizing: "border", overflow: "hidden", children: [
      /* @__PURE__ */ jsx(Header, { paddingX: 3, paddingY: 2, children: /* @__PURE__ */ jsxs(Grid, { columns: [1, 4, 8, 12], children: [
        /* @__PURE__ */ jsx(Box, { padding: 1, column: 2, children: /* @__PURE__ */ jsxs(Stack, { children: [
          /* @__PURE__ */ jsx(Card, { paddingTop: 2, paddingBottom: 3, children: /* @__PURE__ */ jsx(StyledLabel, { children: t("settings.dataset-label") }) }),
          /* @__PURE__ */ jsx(Select, { value: dataset, onChange: this.handleChangeDataset, children: datasets.map((ds) => /* @__PURE__ */ jsx("option", { children: ds }, ds)) })
        ] }) }),
        /* @__PURE__ */ jsx(Box, { padding: 1, column: 2, children: /* @__PURE__ */ jsxs(Stack, { children: [
          /* @__PURE__ */ jsx(Card, { paddingTop: 2, paddingBottom: 3, children: /* @__PURE__ */ jsx(StyledLabel, { children: t("settings.api-version-label") }) }),
          /* @__PURE__ */ jsxs(Select, { value: customApiVersion === !1 ? apiVersion : "other", onChange: this.handleChangeApiVersion, children: [
            API_VERSIONS.map((version) => /* @__PURE__ */ jsx("option", { children: version }, version)),
            /* @__PURE__ */ jsx("option", { value: "other", children: t("settings.other-api-version-label") }, "other")
          ] })
        ] }) }),
        customApiVersion !== !1 && /* @__PURE__ */ jsx(Box, { padding: 1, column: 2, children: /* @__PURE__ */ jsxs(Stack, { children: [
          /* @__PURE__ */ jsx(Card, { paddingTop: 2, paddingBottom: 3, children: /* @__PURE__ */ jsx(StyledLabel, { textOverflow: "ellipsis", children: t("settings.custom-api-version-label") }) }),
          /* @__PURE__ */ jsx(TextInput, { ref: this._customApiVersionElement, value: customApiVersion, onChange: this.handleCustomApiVersionChange, customValidity: isValidApiVersion ? void 0 : t("settings.error.invalid-api-version"), maxLength: 11 })
        ] }) }),
        /* @__PURE__ */ jsx(Box, { padding: 1, column: 2, children: /* @__PURE__ */ jsxs(Stack, { children: [
          /* @__PURE__ */ jsx(Card, { paddingBottom: 1, children: /* @__PURE__ */ jsxs(Inline, { space: 1, children: [
            /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(StyledLabel, { children: t("settings.perspective-label") }) }),
            /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(PerspectivePopover, {}) })
          ] }) }),
          /* @__PURE__ */ jsx(Select, { value: perspective || "default", onChange: this.handleChangePerspective, children: SUPPORTED_PERSPECTIVES.map((perspectiveName) => perspectiveName === "pinnedRelease" ? /* @__PURE__ */ jsxs(Fragment, { children: [
            /* @__PURE__ */ jsx(PinnedReleasePerspectiveOption, { pinnedPerspective, t }),
            /* @__PURE__ */ jsx("option", { value: "default", children: t("settings.perspectives.default") }, "default"),
            /* @__PURE__ */ jsx("hr", {})
          ] }, "pinnedRelease") : /* @__PURE__ */ jsx("option", { children: perspectiveName }, perspectiveName)) })
        ] }) }),
        typeof url == "string" ? /* @__PURE__ */ jsx(Box, { padding: 1, flex: 1, column: customApiVersion === !1 ? 6 : 4, children: /* @__PURE__ */ jsxs(Stack, { children: [
          /* @__PURE__ */ jsx(Card, { paddingTop: 2, paddingBottom: 3, children: /* @__PURE__ */ jsxs(StyledLabel, { children: [
            t("query.url"),
            "\xA0",
            /* @__PURE__ */ jsxs(QueryCopyLink, { onClick: this.handleCopyUrl, children: [
              "[",
              t("action.copy-url-to-clipboard"),
              "]"
            ] })
          ] }) }),
          /* @__PURE__ */ jsxs(Flex, { flex: 1, gap: 1, children: [
            /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(TextInput, { readOnly: !0, type: "url", ref: this._operationUrlElement, value: url }) }),
            /* @__PURE__ */ jsx(Tooltip, { content: t("action.copy-url-to-clipboard"), children: /* @__PURE__ */ jsx(Button, { "aria-label": t("action.copy-url-to-clipboard"), type: "button", mode: "ghost", icon: CopyIcon, onClick: this.handleCopyUrl }) })
          ] })
        ] }) }) : /* @__PURE__ */ jsx(Box, { flex: 1 })
      ] }) }),
      /* @__PURE__ */ jsx(SplitpaneContainer, { flex: "auto", children: /* @__PURE__ */ jsxs(
        SplitPane,
        {
          split: narrowBreakpoint() ? "vertical" : "horizontal",
          minSize: 280,
          defaultSize: 400,
          maxSize: -400,
          children: [
            /* @__PURE__ */ jsx(Box, { height: "stretch", flex: 1, children: /* @__PURE__ */ jsxs(SplitPane, { className: "sidebarPanes", split: "horizontal", defaultSize: narrowBreakpoint() ? paneSizeOptions.defaultSize : paneSizeOptions.minSize, size: paneSizeOptions.size, allowResize: paneSizeOptions.allowResize, minSize: narrowBreakpoint() ? paneSizeOptions.minSize : 100, maxSize: paneSizeOptions.maxSize, primary: "first", children: [
              /* @__PURE__ */ jsx(InputContainer, { display: "flex", ref: this._queryEditorContainer, children: /* @__PURE__ */ jsxs(Box, { flex: 1, children: [
                /* @__PURE__ */ jsx(InputBackgroundContainerLeft, { children: /* @__PURE__ */ jsx(Flex, { children: /* @__PURE__ */ jsx(StyledLabel, { muted: !0, children: t("query.label") }) }) }),
                /* @__PURE__ */ jsx(VisionCodeMirror, { value: query, onChange: this.handleQueryChange, onPasteCapture: this.handleOnPasteCapture })
              ] }) }),
              /* @__PURE__ */ jsxs(InputContainer, { display: "flex", ref: this._paramsEditorContainer, children: [
                /* @__PURE__ */ jsxs(Card, { flex: 1, tone: hasValidParams ? "default" : "critical", children: [
                  /* @__PURE__ */ jsx(InputBackgroundContainerLeft, { children: /* @__PURE__ */ jsxs(Flex, { children: [
                    /* @__PURE__ */ jsx(StyledLabel, { muted: !0, children: t("params.label") }),
                    paramsError && /* @__PURE__ */ jsx(Tooltip, { placement: "top-end", portal: !0, content: paramsError, children: /* @__PURE__ */ jsx(Box, { padding: 1, marginX: 2, children: /* @__PURE__ */ jsx(Text, { children: /* @__PURE__ */ jsx(ErrorOutlineIcon, {}) }) }) })
                  ] }) }),
                  /* @__PURE__ */ jsx(ParamsEditor, { value: rawParams, onChange: this.handleParamsChange, onPasteCapture: this.handleOnPasteCapture })
                ] }),
                /* @__PURE__ */ jsx(ControlsContainer, { children: /* @__PURE__ */ jsx(Card, { padding: 3, paddingX: 3, children: /* @__PURE__ */ jsx(Tooltip, { content: /* @__PURE__ */ jsx(Card, { radius: 4, children: /* @__PURE__ */ jsx(Text, { size: 1, muted: !0, children: t("params.error.params-invalid-json") }) }), placement: "top", disabled: hasValidParams, portal: !0, children: /* @__PURE__ */ jsxs(Flex, { justify: "space-evenly", children: [
                  /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(Tooltip, { content: /* @__PURE__ */ jsx(Card, { radius: 4, children: /* @__PURE__ */ jsx(Hotkeys, { keys: ["Ctrl", "Enter"] }) }), placement: "top", portal: !0, children: /* @__PURE__ */ jsx(Button, { width: "fill", onClick: this.handleQueryExecution, type: "button", icon: queryInProgress ? StopIcon : PlayIcon, disabled: listenInProgress || !hasValidParams, tone: queryInProgress ? "positive" : "primary", text: t(queryInProgress ? "action.query-cancel" : "action.query-execute") }) }) }),
                  /* @__PURE__ */ jsx(Box, { flex: 1, marginLeft: 3, children: /* @__PURE__ */ jsx(Button, { width: "fill", onClick: this.handleListenExecution, type: "button", icon: listenInProgress ? StopIcon : PlayIcon, text: t(listenInProgress ? "action.listen-cancel" : "action.listen-execute"), mode: "ghost", disabled: !hasValidParams, tone: listenInProgress ? "positive" : "default" }) })
                ] }) }) }) })
              ] })
            ] }) }),
            /* @__PURE__ */ jsxs(ResultOuterContainer, { direction: "column", children: [
              /* @__PURE__ */ jsx(ResultInnerContainer, { flex: 1, children: /* @__PURE__ */ jsx(ResultContainer, { flex: 1, overflow: "hidden", tone: error ? "critical" : "default", $isInvalid: !!error, children: /* @__PURE__ */ jsxs(Result, { overflow: "auto", children: [
                /* @__PURE__ */ jsx(InputBackgroundContainer, { children: /* @__PURE__ */ jsx(Box, { marginLeft: 3, children: /* @__PURE__ */ jsx(StyledLabel, { muted: !0, children: t("result.label") }) }) }),
                /* @__PURE__ */ jsxs(Box, { padding: 3, paddingTop: 5, children: [
                  (queryInProgress || listenInProgress && listenMutations.length === 0) && /* @__PURE__ */ jsx(Box, { marginTop: 3, children: /* @__PURE__ */ jsx(DelayedSpinner, {}) }),
                  error && /* @__PURE__ */ jsx(QueryErrorDialog, { error }),
                  hasResult && /* @__PURE__ */ jsx(ResultView, { data: queryResult, datasetName: dataset }),
                  listenInProgress && listenMutations.length > 0 && /* @__PURE__ */ jsx(ResultView, { data: listenMutations, datasetName: dataset })
                ] })
              ] }) }) }),
              /* @__PURE__ */ jsxs(ResultFooter, { justify: "space-between", direction: ["column", "column", "row"], children: [
                /* @__PURE__ */ jsx(TimingsCard, { paddingX: 4, paddingY: 3, sizing: "border", children: /* @__PURE__ */ jsxs(TimingsTextContainer, { align: "center", children: [
                  /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(Text, { muted: !0, children: [
                    t("result.execution-time-label"),
                    ":",
                    " ",
                    typeof queryTime == "number" ? `${queryTime}ms` : t("result.timing-not-applicable")
                  ] }) }),
                  /* @__PURE__ */ jsx(Box, { marginLeft: 4, children: /* @__PURE__ */ jsxs(Text, { muted: !0, children: [
                    t("result.end-to-end-time-label"),
                    ":",
                    " ",
                    typeof e2eTime == "number" ? `${e2eTime}ms` : t("result.timing-not-applicable")
                  ] }) })
                ] }) }),
                hasResult && /* @__PURE__ */ jsx(DownloadsCard, { paddingX: 4, paddingY: 3, sizing: "border", children: /* @__PURE__ */ jsx(SaveResultLabel, { muted: !0, children: /* @__PURE__ */ jsx(Translate, { components: {
                  SaveResultButtons: () => /* @__PURE__ */ jsxs(Fragment$1, { children: [
                    /* @__PURE__ */ jsx(SaveJsonButton, { blobUrl: jsonUrl }),
                    /* @__PURE__ */ jsx(SaveCsvButton, { blobUrl: csvUrl })
                  ] })
                }, i18nKey: "result.save-result-as-format", t }) }) })
              ] })
            ] })
          ]
        }
      ) })
    ] });
  }
}
function getActivePerspective({
  visionPerspective,
  pinnedPerspective
}) {
  if (visionPerspective !== "pinnedRelease")
    return visionPerspective;
  if (pinnedPerspective.perspectiveStack.length !== 0)
    return pinnedPerspective.perspectiveStack;
  if (typeof pinnedPerspective.selectedPerspectiveName < "u")
    return [pinnedPerspective.selectedPerspectiveName];
}
const PinnedReleasePerspectiveOption = (t0) => {
  const $ = c(9), {
    pinnedPerspective,
    t
  } = t0, name = typeof pinnedPerspective.selectedPerspective == "object" ? pinnedPerspective.selectedPerspective.metadata.title : pinnedPerspective.selectedPerspectiveName;
  let t1;
  $[0] !== pinnedPerspective || $[1] !== t ? (t1 = hasPinnedPerspective(pinnedPerspective) ? `(${t("settings.perspectives.pinned-release-label")})` : t("settings.perspectives.pinned-release-label"), $[0] = pinnedPerspective, $[1] = t, $[2] = t1) : t1 = $[2];
  const label = t1;
  let t2, t3;
  $[3] !== label || $[4] !== name ? (t3 = [name, label].filter(_temp$1), $[3] = label, $[4] = name, $[5] = t3) : t3 = $[5], t2 = t3.join(" ");
  const text = t2, t4 = !hasPinnedPerspective(pinnedPerspective);
  let t5;
  return $[6] !== t4 || $[7] !== text ? (t5 = /* @__PURE__ */ jsx("option", { value: "pinnedRelease", disabled: t4, children: text }), $[6] = t4, $[7] = text, $[8] = t5) : t5 = $[8], t5;
};
function hasPinnedPerspective({
  selectedPerspectiveName
}) {
  return typeof selectedPerspectiveName < "u";
}
function hasPinnedPerspectiveChanged(previous, next) {
  const hasPerspectiveStackChanged = !isEqual(previous.perspectiveStack, next.perspectiveStack);
  return previous.selectedPerspectiveName !== next.selectedPerspectiveName || hasPerspectiveStackChanged;
}
function _temp$1(value) {
  return typeof value < "u";
}
function useDatasets(client) {
  const $ = c(7);
  let t0;
  $[0] !== client ? (t0 = client.config(), $[0] = client, $[1] = t0) : t0 = $[1];
  const projectId = t0.projectId, [datasets, setDatasets] = useState();
  let t1;
  $[2] !== client.observable.datasets ? (t1 = () => {
    const datasets$ = client.observable.datasets.list().subscribe({
      next: (result) => setDatasets(result.map(_temp)),
      error: (err) => setDatasets(err)
    });
    return () => datasets$.unsubscribe();
  }, $[2] = client.observable.datasets, $[3] = t1) : t1 = $[3];
  let t2;
  return $[4] !== client || $[5] !== projectId ? (t2 = [client, projectId], $[4] = client, $[5] = projectId, $[6] = t2) : t2 = $[6], useEffect(t1, t2), datasets || void 0;
}
function _temp(ds) {
  return ds.name;
}
function VisionContainer(props) {
  const $ = c(9), toast = useToast(), loadedDatasets = useDatasets(props.client), {
    t
  } = useTranslation(visionLocaleNamespace);
  if (!loadedDatasets) {
    let t02;
    return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t02 = /* @__PURE__ */ jsx(Flex, { align: "center", height: "fill", justify: "center", children: /* @__PURE__ */ jsx(DelayedSpinner, {}) }), $[0] = t02) : t02 = $[0], t02;
  }
  let t0;
  $[1] !== loadedDatasets || $[2] !== props.client ? (t0 = loadedDatasets instanceof Error ? [props.client.config().dataset || "production"] : loadedDatasets, $[1] = loadedDatasets, $[2] = props.client, $[3] = t0) : t0 = $[3];
  const datasets = t0;
  let t1;
  return $[4] !== datasets || $[5] !== props || $[6] !== t || $[7] !== toast ? (t1 = /* @__PURE__ */ jsx(VisionGui, { ...props, datasets, toast, t }), $[4] = datasets, $[5] = props, $[6] = t, $[7] = toast, $[8] = t1) : t1 = $[8], t1;
}
class VisionErrorBoundary extends Component {
  constructor(props) {
    super(props), this.state = {
      error: null,
      numRetries: 0
    };
  }
  static getDerivedStateFromError(error) {
    return {
      error: error instanceof Error ? error.message : `${error}`
    };
  }
  handleRetryRender = () => this.setState((prev) => ({
    error: null,
    numRetries: prev.numRetries + 1
  }));
  handleRetryWithCacheClear = () => {
    clearLocalStorage(), this.handleRetryRender();
  };
  render() {
    if (!this.state.error)
      return this.props.children;
    const message = this.state.error, withCacheClear = this.state.numRetries > 0;
    return /* @__PURE__ */ jsx(Card, { height: "fill", overflow: "auto", paddingY: [4, 5, 6, 7], paddingX: 4, sizing: "border", tone: "critical", children: /* @__PURE__ */ jsx(Container, { width: 3, children: /* @__PURE__ */ jsxs(Stack, { space: 4, children: [
      /* @__PURE__ */ jsx("div", { children: /* @__PURE__ */ jsx(Button, { onClick: withCacheClear ? this.handleRetryWithCacheClear : this.handleRetryRender, text: withCacheClear ? "Clear cache and retry" : "Retry", tone: "default" }) }),
      /* @__PURE__ */ jsx(Heading, { children: "An error occurred" }),
      /* @__PURE__ */ jsx(Card, { border: !0, radius: 2, overflow: "auto", padding: 4, tone: "inherit", children: /* @__PURE__ */ jsx(Stack, { space: 4, children: message && /* @__PURE__ */ jsx(Code, { size: 1, children: /* @__PURE__ */ jsxs("strong", { children: [
        "Error: ",
        message
      ] }) }) }) })
    ] }) }) });
  }
}
function SanityVision(props) {
  const $ = c(7);
  let t0;
  $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = {
    apiVersion: "1"
  }, $[0] = t0) : t0 = $[0];
  const client = useClient(t0), perspective = usePerspective();
  let t1;
  $[1] !== props.tool.options ? (t1 = {
    defaultApiVersion: DEFAULT_API_VERSION,
    ...props.tool.options
  }, $[1] = props.tool.options, $[2] = t1) : t1 = $[2];
  const config = t1;
  let t2;
  return $[3] !== client || $[4] !== config || $[5] !== perspective ? (t2 = /* @__PURE__ */ jsx(VisionErrorBoundary, { children: /* @__PURE__ */ jsx(VisionContainer, { client, config, pinnedPerspective: perspective }) }), $[3] = client, $[4] = config, $[5] = perspective, $[6] = t2) : t2 = $[6], t2;
}
export {
  SanityVision as default
};
//# sourceMappingURL=SanityVision.esm.js.map
