import type {
  ArraySchemaType,
  BlockDecoratorDefinition,
  BlockListDefinition,
  BlockStyleDefinition,
  ObjectSchemaType,
  Path,
  PathSegment,
  PortableTextChild,
  PortableTextTextBlock,
} from '@sanity/types'
import {
  KeyedSegment,
  PortableTextBlock,
  PortableTextObject,
  PortableTextSpan,
} from '@sanity/types'

/**
 * @beta
 */
export declare type BlockOffset = {
  path: [KeyedSegment]
  offset: number
}

/**
 * @public
 */
export declare function blockOffsetsToSelection({
  value,
  offsets,
  backward,
}: {
  value: Array<PortableTextBlock>
  offsets: {
    anchor: BlockOffset
    focus: BlockOffset
  }
  backward?: boolean
}): EditorSelection

/**
 * @public
 */
export declare function blockOffsetToSpanSelectionPoint({
  value,
  blockOffset,
  direction,
}: {
  value: Array<PortableTextBlock>
  blockOffset: BlockOffset
  direction: 'forward' | 'backward'
}):
  | {
      path: [KeyedSegment, 'children', KeyedSegment]
      offset: number
    }
  | undefined

declare type Converter<TMIMEType extends MIMEType = MIMEType> = {
  mimeType: TMIMEType
  serialize: Serializer<TMIMEType>
  deserialize: Deserializer<TMIMEType>
}

declare type ConverterEvent<TMIMEType extends MIMEType = MIMEType> =
  | {
      type: 'serialize'
      originEvent: 'copy' | 'cut' | 'unknown'
    }
  | {
      type: 'serialization.failure'
      mimeType: TMIMEType
      reason: string
    }
  | {
      type: 'serialization.success'
      data: string
      mimeType: TMIMEType
      originEvent: 'copy' | 'cut' | 'unknown'
    }
  | {
      type: 'deserialize'
      data: string
    }
  | {
      type: 'deserialization.failure'
      mimeType: TMIMEType
      reason: string
    }
  | {
      type: 'deserialization.success'
      data: Array<PortableTextBlock>
      mimeType: TMIMEType
    }

declare type Deserializer<TMIMEType extends MIMEType> = ({
  context,
  event,
}: {
  context: EditorContext
  event: PickFromUnion<ConverterEvent<TMIMEType>, 'type', 'deserialize'>
}) => PickFromUnion<
  ConverterEvent<TMIMEType>,
  'type',
  'deserialization.success' | 'deserialization.failure'
>

/**
 * @public
 */
declare type EditorContext = {
  activeDecorators: Array<string>
  converters: Array<Converter>
  keyGenerator: () => string
  schema: EditorSchema
  selection: EditorSelection
  value: Array<PortableTextBlock>
}

/**
 * @public
 */
declare type EditorSchema = PortableTextMemberSchemaTypes

/** @public */
export declare type EditorSelection = {
  anchor: EditorSelectionPoint
  focus: EditorSelectionPoint
  backward?: boolean
} | null

/** @public */
export declare type EditorSelectionPoint = {
  path: Path
  offset: number
}

/**
 * @public
 */
export declare function getBlockEndPoint({
  node,
  path,
}: {
  node: PortableTextBlock
  path: [KeyedSegment]
}): EditorSelectionPoint

/**
 * @public
 */
export declare function getBlockStartPoint({
  node,
  path,
}: {
  node: PortableTextBlock
  path: [KeyedSegment]
}): EditorSelectionPoint

/**
 * @public
 */
export declare function getTextBlockText(block: PortableTextTextBlock): string

/**
 * @public
 */
export declare function isEmptyTextBlock(block: PortableTextBlock): boolean

/**
 * @public
 */
export declare function isEqualSelectionPoints(
  a: EditorSelectionPoint,
  b: EditorSelectionPoint,
): boolean

/**
 * @public
 */
export declare function isKeyedSegment(
  segment: PathSegment,
): segment is KeyedSegment

/**
 * @public
 */
export declare function isSpan(
  context: Pick<EditorContext, 'schema'>,
  child: PortableTextChild,
): child is PortableTextSpan

/**
 * @public
 */
export declare function isTextBlock(
  context: Pick<EditorContext, 'schema'>,
  block: PortableTextBlock,
): block is PortableTextTextBlock

/**
 * @beta
 */
export declare function mergeTextBlocks({
  context,
  targetBlock,
  incomingBlock,
}: {
  context: Pick<EditorContext, 'keyGenerator' | 'schema'>
  targetBlock: PortableTextTextBlock
  incomingBlock: PortableTextTextBlock
}): PortableTextTextBlock<PortableTextSpan | PortableTextObject>

declare type MIMEType = `${string}/${string}`

/**
 * @internal
 */
declare type PickFromUnion<
  TUnion,
  TTagKey extends keyof TUnion,
  TPickedTags extends TUnion[TTagKey],
> = TUnion extends Record<TTagKey, TPickedTags> ? TUnion : never

/** @internal */
declare type PortableTextMemberSchemaTypes = {
  annotations: (ObjectSchemaType & {
    i18nTitleKey?: string
  })[]
  block: ObjectSchemaType
  blockObjects: ObjectSchemaType[]
  decorators: BlockDecoratorDefinition[]
  inlineObjects: ObjectSchemaType[]
  portableText: ArraySchemaType<PortableTextBlock>
  span: ObjectSchemaType
  styles: BlockStyleDefinition[]
  lists: BlockListDefinition[]
}

/**
 * @public
 */
export declare function reverseSelection(
  selection: NonNullable<EditorSelection>,
): NonNullable<EditorSelection>

declare type Serializer<TMIMEType extends MIMEType> = ({
  context,
  event,
}: {
  context: EditorContext
  event: PickFromUnion<ConverterEvent<TMIMEType>, 'type', 'serialize'>
}) => PickFromUnion<
  ConverterEvent<TMIMEType>,
  'type',
  'serialization.success' | 'serialization.failure'
>

/**
 * @public
 */
export declare function sliceBlocks({
  blocks,
  selection,
}: {
  blocks: Array<PortableTextBlock>
  selection: EditorSelection
}): Array<PortableTextBlock>

/**
 * @public
 */
export declare function spanSelectionPointToBlockOffset({
  value,
  selectionPoint,
}: {
  value: Array<PortableTextBlock>
  selectionPoint: EditorSelectionPoint
}): BlockOffset | undefined

/**
 * @beta
 */
export declare function splitTextBlock({
  context,
  block,
  point,
}: {
  context: Pick<EditorContext, 'schema'>
  block: PortableTextTextBlock
  point: EditorSelectionPoint
}):
  | {
      before: PortableTextTextBlock
      after: PortableTextTextBlock
    }
  | undefined

export {}
