{"version":3,"file":"selector.is-at-the-start-of-block.cjs","sources":["../../src/behavior-actions/behavior.guards.ts","../../src/selectors/selectors.ts","../../src/selectors/selector.get-selection-end-point.ts","../../src/selectors/selector.get-selection-start-point.ts","../../src/selectors/selector.get-next-inline-object.ts","../../src/selectors/selector.get-previous-inline-object.ts","../../src/selectors/selector.get-selected-slice.ts","../../src/selectors/selector.get-selection-text.ts","../../src/selectors/selector.is-selection-collapsed.ts","../../src/selectors/selector.is-selection-expanded.ts","../../src/selectors/selector.get-caret-word-selection.ts","../../src/selectors/selector.is-at-the-end-of-block.ts","../../src/selectors/selector.is-at-the-start-of-block.ts"],"sourcesContent":["import {\n  isPortableTextListBlock,\n  isPortableTextTextBlock,\n  type PortableTextListBlock,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport type {EditorSchema} from '../editor/define-schema'\n\n/**\n * @alpha\n */\nexport type BehaviorGuards = ReturnType<typeof createGuards>\n\nexport function createGuards({schema}: {schema: EditorSchema}) {\n  function isListBlock(block: unknown): block is PortableTextListBlock {\n    return isPortableTextListBlock(block) && block._type === schema.block.name\n  }\n\n  function isTextBlock(block: unknown): block is PortableTextTextBlock {\n    return isPortableTextTextBlock(block) && block._type === schema.block.name\n  }\n\n  return {isListBlock, isTextBlock}\n}\n","import {\n  isKeySegment,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n  type PortableTextListBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport {createGuards} from '../behavior-actions/behavior.guards'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getFocusBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const key = context.selection\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusListBlock: EditorSelector<\n  {node: PortableTextListBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const guards = createGuards(context)\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && guards.isListBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && isPortableTextTextBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusBlockObject: EditorSelector<\n  {node: PortableTextObject; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && !isPortableTextTextBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  const focusBlock = getFocusTextBlock({context})\n\n  if (!focusBlock) {\n    return undefined\n  }\n\n  const key = context.selection\n    ? isKeySegment(context.selection.focus.path[2])\n      ? context.selection.focus.path[2]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? focusBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...focusBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusSpan: EditorSelector<\n  | {node: PortableTextSpan; path: [KeyedSegment, 'children', KeyedSegment]}\n  | undefined\n> = ({context}) => {\n  const focusChild = getFocusChild({context})\n\n  return focusChild && isPortableTextSpan(focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFirstBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const node = context.value[0]\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getLastBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const node = context.value[context.value.length - 1]\n    ? context.value[context.value.length - 1]\n    : undefined\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getSelectedBlocks: EditorSelector<\n  Array<{node: PortableTextBlock; path: [KeyedSegment]}>\n> = ({context}) => {\n  if (!context.selection) {\n    return []\n  }\n\n  const selectedBlocks: Array<{node: PortableTextBlock; path: [KeyedSegment]}> =\n    []\n  const startKey = context.selection.backward\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n  const endKey = context.selection.backward\n    ? isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n\n  if (!startKey || !endKey) {\n    return selectedBlocks\n  }\n\n  for (const block of context.value) {\n    if (block._key === startKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n      break\n    }\n\n    if (selectedBlocks.length > 0) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n    }\n  }\n\n  return selectedBlocks\n}\n\n/**\n * @public\n */\nexport const getSelectionStartBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const key = context.selection.backward\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getSelectionEndBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const key = context.selection.backward\n    ? isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getPreviousBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  let previousBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionStartBlock = getSelectionStartBlock({context})\n\n  if (!selectionStartBlock) {\n    return undefined\n  }\n\n  let foundSelectionStartBlock = false\n\n  for (const block of context.value) {\n    if (block._key === selectionStartBlock.node._key) {\n      foundSelectionStartBlock = true\n      break\n    }\n\n    previousBlock = {node: block, path: [{_key: block._key}]}\n  }\n\n  if (foundSelectionStartBlock && previousBlock) {\n    return previousBlock\n  }\n\n  return undefined\n}\n\n/**\n * @public\n */\nexport const getNextBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  let nextBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionEndBlock = getSelectionEndBlock({context})\n\n  if (!selectionEndBlock) {\n    return undefined\n  }\n\n  let foundSelectionEndBlock = false\n\n  for (const block of context.value) {\n    if (block._key === selectionEndBlock.node._key) {\n      foundSelectionEndBlock = true\n      continue\n    }\n\n    if (foundSelectionEndBlock) {\n      nextBlock = {node: block, path: [{_key: block._key}]}\n      break\n    }\n  }\n\n  if (foundSelectionEndBlock && nextBlock) {\n    return nextBlock\n  }\n\n  return undefined\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectionEndPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  return context.selection.backward\n    ? context.selection.anchor\n    : context.selection.focus\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectionStartPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  return context.selection.backward\n    ? context.selection.focus\n    : context.selection.anchor\n}\n","import {\n  isKeySegment,\n  type KeyedSegment,\n  type PortableTextObject,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan} from '../utils'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getNextInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  const focusTextBlock = getFocusTextBlock({context})\n  const selectionEndPoint = getSelectionEndPoint({context})\n  const selectionEndPointChildKey =\n    selectionEndPoint && isKeySegment(selectionEndPoint.path[2])\n      ? selectionEndPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionEndPointChildKey) {\n    return undefined\n  }\n\n  let endPointChildFound = false\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (!isSpan(context, child) && endPointChildFound) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n      break\n    }\n  }\n\n  return inlineObject\n}\n","import {\n  isKeySegment,\n  type KeyedSegment,\n  type PortableTextObject,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan} from '../utils'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getPreviousInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  const focusTextBlock = getFocusTextBlock({context})\n  const selectionStartPoint = getSelectionStartPoint({context})\n  const selectionStartPointChildKey =\n    selectionStartPoint && isKeySegment(selectionStartPoint.path[2])\n      ? selectionStartPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionStartPointChildKey) {\n    return undefined\n  }\n\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (!isSpan(context, child)) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n    }\n  }\n\n  return inlineObject\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {sliceBlocks} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectedSlice: EditorSelector<Array<PortableTextBlock>> = ({\n  context,\n}) => {\n  return sliceBlocks({blocks: context.value, selection: context.selection})\n}\n","import {isPortableTextSpan, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSlice} from './selector.get-selected-slice'\n\n/**\n * @public\n */\nexport const getSelectionText: EditorSelector<string> = ({context}) => {\n  const selectedSlice = getSelectedSlice({context})\n\n  return selectedSlice.reduce((text, block) => {\n    if (!isPortableTextTextBlock(block)) {\n      return text\n    }\n\n    return (\n      text +\n      block.children.reduce((text, child) => {\n        if (isPortableTextSpan(child)) {\n          return text + child.text\n        }\n\n        return text\n      }, '')\n    )\n  }, '')\n}\n","import type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const isSelectionCollapsed: EditorSelector<boolean> = ({context}) => {\n  if (!context.selection) {\n    return false\n  }\n\n  return (\n    JSON.stringify(context.selection.anchor.path) ===\n      JSON.stringify(context.selection.focus.path) &&\n    context.selection?.anchor.offset === context.selection?.focus.offset\n  )\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport const isSelectionExpanded: EditorSelector<boolean> = ({context}) => {\n  return !isSelectionCollapsed({context})\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelection} from '../types/editor'\nimport {\n  blockOffsetToSpanSelectionPoint,\n  getBlockEndPoint,\n  getBlockStartPoint,\n  spanSelectionPointToBlockOffset,\n  type BlockOffset,\n} from '../utils'\nimport {getNextInlineObject} from './selector.get-next-inline-object'\nimport {getPreviousInlineObject} from './selector.get-previous-inline-object'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getSelectionText} from './selector.get-selection-text'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n * Returns the selection of the of the word the caret is placed in.\n * Note: Only returns a word selection if the current selection is collapsed\n */\nexport const getCaretWordSelection: EditorSelector<EditorSelection> = ({\n  context,\n}) => {\n  if (!context.selection) {\n    return null\n  }\n\n  if (!isSelectionCollapsed({context})) {\n    return null\n  }\n\n  const focusTextBlock = getFocusTextBlock({context})\n  const selectionStartPoint = getSelectionStartPoint({context})\n  const selectionStartOffset = selectionStartPoint\n    ? spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: selectionStartPoint,\n      })\n    : undefined\n\n  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset) {\n    return null\n  }\n\n  const previousInlineObject = getPreviousInlineObject({context})\n  const blockStartPoint = getBlockStartPoint(focusTextBlock)\n  const textBefore = getSelectionText({\n    context: {\n      ...context,\n      selection: {\n        anchor: previousInlineObject\n          ? {path: previousInlineObject.path, offset: 0}\n          : blockStartPoint,\n        focus: selectionStartPoint,\n      },\n    },\n  })\n  const textDirectlyBefore = textBefore.split(/\\s+/).at(-1)\n\n  const nextInlineObject = getNextInlineObject({context})\n  const blockEndPoint = getBlockEndPoint(focusTextBlock)\n  const textAfter = getSelectionText({\n    context: {\n      ...context,\n      selection: {\n        anchor: selectionStartPoint,\n        focus: nextInlineObject\n          ? {path: nextInlineObject.path, offset: 0}\n          : blockEndPoint,\n      },\n    },\n  })\n  const textDirectlyAfter = textAfter.split(/\\s+/).at(0)\n\n  if (\n    (textDirectlyBefore === undefined || textDirectlyBefore === '') &&\n    (textDirectlyAfter === undefined || textDirectlyAfter === '')\n  ) {\n    return null\n  }\n\n  const caretWordStartOffset: BlockOffset = textDirectlyBefore\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset - textDirectlyBefore.length,\n      }\n    : selectionStartOffset\n  const caretWordEndOffset: BlockOffset = textDirectlyAfter\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset + textDirectlyAfter.length,\n      }\n    : selectionStartOffset\n\n  const caretWordStartSelectionPoint = blockOffsetToSpanSelectionPoint({\n    value: context.value,\n    blockOffset: caretWordStartOffset,\n    direction: 'backward',\n  })\n  const caretWordEndSelectionPoint = blockOffsetToSpanSelectionPoint({\n    value: context.value,\n    blockOffset: caretWordEndOffset,\n    direction: 'forward',\n  })\n\n  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint) {\n    return null\n  }\n\n  const caretWordSelection = {\n    anchor: caretWordStartSelectionPoint,\n    focus: caretWordEndSelectionPoint,\n  }\n\n  return isSelectionExpanded({\n    context: {\n      ...context,\n      selection: caretWordSelection,\n    },\n  })\n    ? caretWordSelection\n    : null\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheEndOfBlock(block: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelector<boolean> {\n  return ({context}) => {\n    if (!context.selection || !isSelectionCollapsed({context})) {\n      return false\n    }\n\n    const blockEndPoint = utils.getBlockEndPoint(block)\n\n    return utils.isEqualSelectionPoints(context.selection.focus, blockEndPoint)\n  }\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheStartOfBlock(block: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelector<boolean> {\n  return ({context}) => {\n    if (!context.selection || !isSelectionCollapsed({context})) {\n      return false\n    }\n\n    const blockStartPoint = utils.getBlockStartPoint(block)\n\n    return utils.isEqualSelectionPoints(\n      context.selection.focus,\n      blockStartPoint,\n    )\n  }\n}\n"],"names":["createGuards","schema","isListBlock","block","isPortableTextListBlock","_type","name","isTextBlock","isPortableTextTextBlock","getFocusBlock","context","key","selection","isKeySegment","focus","path","_key","undefined","node","value","find","getFocusListBlock","guards","focusBlock","getFocusTextBlock","getFocusBlockObject","getFocusChild","children","span","getFocusSpan","focusChild","isPortableTextSpan","getFirstBlock","getLastBlock","length","getSelectedBlocks","selectedBlocks","startKey","backward","anchor","endKey","push","getSelectionStartBlock","getSelectionEndBlock","getPreviousBlock","previousBlock","selectionStartBlock","foundSelectionStartBlock","getNextBlock","nextBlock","selectionEndBlock","foundSelectionEndBlock","getSelectionEndPoint","getSelectionStartPoint","getNextInlineObject","focusTextBlock","selectionEndPoint","selectionEndPointChildKey","endPointChildFound","inlineObject","child","isSpan","getPreviousInlineObject","selectionStartPoint","selectionStartPointChildKey","getSelectedSlice","sliceBlocks","blocks","getSelectionText","reduce","text","isSelectionCollapsed","JSON","stringify","offset","isSelectionExpanded","getCaretWordSelection","selectionStartOffset","spanSelectionPointToBlockOffset","selectionPoint","previousInlineObject","blockStartPoint","getBlockStartPoint","textDirectlyBefore","split","at","nextInlineObject","blockEndPoint","getBlockEndPoint","textDirectlyAfter","caretWordStartOffset","caretWordEndOffset","caretWordStartSelectionPoint","blockOffsetToSpanSelectionPoint","blockOffset","direction","caretWordEndSelectionPoint","caretWordSelection","isAtTheEndOfBlock","utils","isEqualSelectionPoints","isAtTheStartOfBlock"],"mappings":"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"}