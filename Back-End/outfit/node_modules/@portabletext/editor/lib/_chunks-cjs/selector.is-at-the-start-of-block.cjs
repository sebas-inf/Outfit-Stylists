"use strict";
var util_sliceBlocks = require("./util.slice-blocks.cjs"), types = require("@sanity/types");
function createGuards({
  schema
}) {
  function isListBlock(block) {
    return types.isPortableTextListBlock(block) && block._type === schema.block.name;
  }
  function isTextBlock(block) {
    return types.isPortableTextTextBlock(block) && block._type === schema.block.name;
  }
  return {
    isListBlock,
    isTextBlock
  };
}
const getFocusBlock = ({
  context
}) => {
  const key = context.selection && types.isKeySegment(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;
  return node && key ? {
    node,
    path: [{
      _key: key
    }]
  } : void 0;
}, getFocusListBlock = ({
  context
}) => {
  const guards = createGuards(context), focusBlock = getFocusBlock({
    context
  });
  return focusBlock && guards.isListBlock(focusBlock.node) ? {
    node: focusBlock.node,
    path: focusBlock.path
  } : void 0;
}, getFocusTextBlock = ({
  context
}) => {
  const focusBlock = getFocusBlock({
    context
  });
  return focusBlock && types.isPortableTextTextBlock(focusBlock.node) ? {
    node: focusBlock.node,
    path: focusBlock.path
  } : void 0;
}, getFocusBlockObject = ({
  context
}) => {
  const focusBlock = getFocusBlock({
    context
  });
  return focusBlock && !types.isPortableTextTextBlock(focusBlock.node) ? {
    node: focusBlock.node,
    path: focusBlock.path
  } : void 0;
}, getFocusChild = ({
  context
}) => {
  const focusBlock = getFocusTextBlock({
    context
  });
  if (!focusBlock)
    return;
  const key = context.selection && types.isKeySegment(context.selection.focus.path[2]) ? context.selection.focus.path[2]._key : void 0, node = key ? focusBlock.node.children.find((span) => span._key === key) : void 0;
  return node && key ? {
    node,
    path: [...focusBlock.path, "children", {
      _key: key
    }]
  } : void 0;
}, getFocusSpan = ({
  context
}) => {
  const focusChild = getFocusChild({
    context
  });
  return focusChild && types.isPortableTextSpan(focusChild.node) ? {
    node: focusChild.node,
    path: focusChild.path
  } : void 0;
}, getFirstBlock = ({
  context
}) => {
  const node = context.value[0];
  return node ? {
    node,
    path: [{
      _key: node._key
    }]
  } : void 0;
}, getLastBlock = ({
  context
}) => {
  const node = context.value[context.value.length - 1] ? context.value[context.value.length - 1] : void 0;
  return node ? {
    node,
    path: [{
      _key: node._key
    }]
  } : void 0;
}, getSelectedBlocks = ({
  context
}) => {
  if (!context.selection)
    return [];
  const selectedBlocks = [], startKey = context.selection.backward ? types.isKeySegment(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0 : types.isKeySegment(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0, endKey = context.selection.backward ? types.isKeySegment(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0 : types.isKeySegment(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0;
  if (!startKey || !endKey)
    return selectedBlocks;
  for (const block of context.value) {
    if (block._key === startKey) {
      if (selectedBlocks.push({
        node: block,
        path: [{
          _key: block._key
        }]
      }), startKey === endKey)
        break;
      continue;
    }
    if (block._key === endKey) {
      selectedBlocks.push({
        node: block,
        path: [{
          _key: block._key
        }]
      });
      break;
    }
    selectedBlocks.length > 0 && selectedBlocks.push({
      node: block,
      path: [{
        _key: block._key
      }]
    });
  }
  return selectedBlocks;
}, getSelectionStartBlock = ({
  context
}) => {
  if (!context.selection)
    return;
  const key = context.selection.backward ? types.isKeySegment(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0 : types.isKeySegment(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;
  return node && key ? {
    node,
    path: [{
      _key: key
    }]
  } : void 0;
}, getSelectionEndBlock = ({
  context
}) => {
  if (!context.selection)
    return;
  const key = context.selection.backward ? types.isKeySegment(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0 : types.isKeySegment(context.selection.focus.path[0]) ? context.selection.focus.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;
  return node && key ? {
    node,
    path: [{
      _key: key
    }]
  } : void 0;
}, getPreviousBlock = ({
  context
}) => {
  let previousBlock;
  const selectionStartBlock = getSelectionStartBlock({
    context
  });
  if (!selectionStartBlock)
    return;
  let foundSelectionStartBlock = !1;
  for (const block of context.value) {
    if (block._key === selectionStartBlock.node._key) {
      foundSelectionStartBlock = !0;
      break;
    }
    previousBlock = {
      node: block,
      path: [{
        _key: block._key
      }]
    };
  }
  if (foundSelectionStartBlock && previousBlock)
    return previousBlock;
}, getNextBlock = ({
  context
}) => {
  let nextBlock;
  const selectionEndBlock = getSelectionEndBlock({
    context
  });
  if (!selectionEndBlock)
    return;
  let foundSelectionEndBlock = !1;
  for (const block of context.value) {
    if (block._key === selectionEndBlock.node._key) {
      foundSelectionEndBlock = !0;
      continue;
    }
    if (foundSelectionEndBlock) {
      nextBlock = {
        node: block,
        path: [{
          _key: block._key
        }]
      };
      break;
    }
  }
  if (foundSelectionEndBlock && nextBlock)
    return nextBlock;
}, getSelectionEndPoint = ({
  context
}) => {
  if (context.selection)
    return context.selection.backward ? context.selection.anchor : context.selection.focus;
}, getSelectionStartPoint = ({
  context
}) => {
  if (context.selection)
    return context.selection.backward ? context.selection.focus : context.selection.anchor;
}, getNextInlineObject = ({
  context
}) => {
  const focusTextBlock = getFocusTextBlock({
    context
  }), selectionEndPoint = getSelectionEndPoint({
    context
  }), selectionEndPointChildKey = selectionEndPoint && types.isKeySegment(selectionEndPoint.path[2]) ? selectionEndPoint.path[2]._key : void 0;
  if (!focusTextBlock || !selectionEndPointChildKey)
    return;
  let endPointChildFound = !1, inlineObject;
  for (const child of focusTextBlock.node.children) {
    if (child._key === selectionEndPointChildKey) {
      endPointChildFound = !0;
      continue;
    }
    if (!util_sliceBlocks.isSpan(context, child) && endPointChildFound) {
      inlineObject = {
        node: child,
        path: [...focusTextBlock.path, "children", {
          _key: child._key
        }]
      };
      break;
    }
  }
  return inlineObject;
}, getPreviousInlineObject = ({
  context
}) => {
  const focusTextBlock = getFocusTextBlock({
    context
  }), selectionStartPoint = getSelectionStartPoint({
    context
  }), selectionStartPointChildKey = selectionStartPoint && types.isKeySegment(selectionStartPoint.path[2]) ? selectionStartPoint.path[2]._key : void 0;
  if (!focusTextBlock || !selectionStartPointChildKey)
    return;
  let inlineObject;
  for (const child of focusTextBlock.node.children) {
    if (child._key === selectionStartPointChildKey)
      break;
    util_sliceBlocks.isSpan(context, child) || (inlineObject = {
      node: child,
      path: [...focusTextBlock.path, "children", {
        _key: child._key
      }]
    });
  }
  return inlineObject;
}, getSelectedSlice = ({
  context
}) => util_sliceBlocks.sliceBlocks({
  blocks: context.value,
  selection: context.selection
}), getSelectionText = ({
  context
}) => getSelectedSlice({
  context
}).reduce((text, block) => types.isPortableTextTextBlock(block) ? text + block.children.reduce((text2, child) => types.isPortableTextSpan(child) ? text2 + child.text : text2, "") : text, ""), isSelectionCollapsed = ({
  context
}) => context.selection ? JSON.stringify(context.selection.anchor.path) === JSON.stringify(context.selection.focus.path) && context.selection?.anchor.offset === context.selection?.focus.offset : !1, isSelectionExpanded = ({
  context
}) => !isSelectionCollapsed({
  context
}), getCaretWordSelection = ({
  context
}) => {
  if (!context.selection || !isSelectionCollapsed({
    context
  }))
    return null;
  const focusTextBlock = getFocusTextBlock({
    context
  }), selectionStartPoint = getSelectionStartPoint({
    context
  }), selectionStartOffset = selectionStartPoint ? util_sliceBlocks.spanSelectionPointToBlockOffset({
    value: context.value,
    selectionPoint: selectionStartPoint
  }) : void 0;
  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset)
    return null;
  const previousInlineObject = getPreviousInlineObject({
    context
  }), blockStartPoint = util_sliceBlocks.getBlockStartPoint(focusTextBlock), textDirectlyBefore = getSelectionText({
    context: {
      ...context,
      selection: {
        anchor: previousInlineObject ? {
          path: previousInlineObject.path,
          offset: 0
        } : blockStartPoint,
        focus: selectionStartPoint
      }
    }
  }).split(/\s+/).at(-1), nextInlineObject = getNextInlineObject({
    context
  }), blockEndPoint = util_sliceBlocks.getBlockEndPoint(focusTextBlock), textDirectlyAfter = getSelectionText({
    context: {
      ...context,
      selection: {
        anchor: selectionStartPoint,
        focus: nextInlineObject ? {
          path: nextInlineObject.path,
          offset: 0
        } : blockEndPoint
      }
    }
  }).split(/\s+/).at(0);
  if ((textDirectlyBefore === void 0 || textDirectlyBefore === "") && (textDirectlyAfter === void 0 || textDirectlyAfter === ""))
    return null;
  const caretWordStartOffset = textDirectlyBefore ? {
    ...selectionStartOffset,
    offset: selectionStartOffset.offset - textDirectlyBefore.length
  } : selectionStartOffset, caretWordEndOffset = textDirectlyAfter ? {
    ...selectionStartOffset,
    offset: selectionStartOffset.offset + textDirectlyAfter.length
  } : selectionStartOffset, caretWordStartSelectionPoint = util_sliceBlocks.blockOffsetToSpanSelectionPoint({
    value: context.value,
    blockOffset: caretWordStartOffset,
    direction: "backward"
  }), caretWordEndSelectionPoint = util_sliceBlocks.blockOffsetToSpanSelectionPoint({
    value: context.value,
    blockOffset: caretWordEndOffset,
    direction: "forward"
  });
  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint)
    return null;
  const caretWordSelection = {
    anchor: caretWordStartSelectionPoint,
    focus: caretWordEndSelectionPoint
  };
  return isSelectionExpanded({
    context: {
      ...context,
      selection: caretWordSelection
    }
  }) ? caretWordSelection : null;
};
function isAtTheEndOfBlock(block) {
  return ({
    context
  }) => {
    if (!context.selection || !isSelectionCollapsed({
      context
    }))
      return !1;
    const blockEndPoint = util_sliceBlocks.getBlockEndPoint(block);
    return util_sliceBlocks.isEqualSelectionPoints(context.selection.focus, blockEndPoint);
  };
}
function isAtTheStartOfBlock(block) {
  return ({
    context
  }) => {
    if (!context.selection || !isSelectionCollapsed({
      context
    }))
      return !1;
    const blockStartPoint = util_sliceBlocks.getBlockStartPoint(block);
    return util_sliceBlocks.isEqualSelectionPoints(context.selection.focus, blockStartPoint);
  };
}
exports.createGuards = createGuards;
exports.getCaretWordSelection = getCaretWordSelection;
exports.getFirstBlock = getFirstBlock;
exports.getFocusBlock = getFocusBlock;
exports.getFocusBlockObject = getFocusBlockObject;
exports.getFocusChild = getFocusChild;
exports.getFocusListBlock = getFocusListBlock;
exports.getFocusSpan = getFocusSpan;
exports.getFocusTextBlock = getFocusTextBlock;
exports.getLastBlock = getLastBlock;
exports.getNextBlock = getNextBlock;
exports.getNextInlineObject = getNextInlineObject;
exports.getPreviousBlock = getPreviousBlock;
exports.getPreviousInlineObject = getPreviousInlineObject;
exports.getSelectedBlocks = getSelectedBlocks;
exports.getSelectedSlice = getSelectedSlice;
exports.getSelectionEndBlock = getSelectionEndBlock;
exports.getSelectionEndPoint = getSelectionEndPoint;
exports.getSelectionStartBlock = getSelectionStartBlock;
exports.getSelectionStartPoint = getSelectionStartPoint;
exports.getSelectionText = getSelectionText;
exports.isAtTheEndOfBlock = isAtTheEndOfBlock;
exports.isAtTheStartOfBlock = isAtTheStartOfBlock;
exports.isSelectionCollapsed = isSelectionCollapsed;
exports.isSelectionExpanded = isSelectionExpanded;
//# sourceMappingURL=selector.is-at-the-start-of-block.cjs.map
