import type {KeyedSegment as KeyedSegment_2} from '@portabletext/patches'
import type {
  ArraySchemaType,
  BlockDecoratorDefinition,
  BlockListDefinition,
  BlockStyleDefinition,
  ObjectSchemaType,
  Path,
  PathSegment,
  PortableTextChild,
} from '@sanity/types'
import {
  KeyedSegment,
  PortableTextBlock,
  PortableTextListBlock,
  PortableTextObject,
  PortableTextSpan,
  PortableTextTextBlock,
} from '@sanity/types'

/**
 * @beta
 */
declare type BlockOffset = {
  path: [KeyedSegment]
  offset: number
}

/**
 * @public
 */
declare function blockOffsetsToSelection({
  value,
  offsets,
  backward,
}: {
  value: Array<PortableTextBlock>
  offsets: {
    anchor: BlockOffset
    focus: BlockOffset
  }
  backward?: boolean
}): EditorSelection

/**
 * @public
 */
declare function blockOffsetToSpanSelectionPoint({
  value,
  blockOffset,
  direction,
}: {
  value: Array<PortableTextBlock>
  blockOffset: BlockOffset
  direction: 'forward' | 'backward'
}):
  | {
      path: [KeyedSegment, 'children', KeyedSegment]
      offset: number
    }
  | undefined

declare type Converter<TMIMEType extends MIMEType = MIMEType> = {
  mimeType: TMIMEType
  serialize: Serializer<TMIMEType>
  deserialize: Deserializer<TMIMEType>
}

declare type ConverterEvent<TMIMEType extends MIMEType = MIMEType> =
  | {
      type: 'serialize'
      originEvent: 'copy' | 'cut' | 'unknown'
    }
  | {
      type: 'serialization.failure'
      mimeType: TMIMEType
      reason: string
    }
  | {
      type: 'serialization.success'
      data: string
      mimeType: TMIMEType
      originEvent: 'copy' | 'cut' | 'unknown'
    }
  | {
      type: 'deserialize'
      data: string
    }
  | {
      type: 'deserialization.failure'
      mimeType: TMIMEType
      reason: string
    }
  | {
      type: 'deserialization.success'
      data: Array<PortableTextBlock>
      mimeType: TMIMEType
    }

declare type Deserializer<TMIMEType extends MIMEType> = ({
  context,
  event,
}: {
  context: EditorContext
  event: PickFromUnion<ConverterEvent<TMIMEType>, 'type', 'deserialize'>
}) => PickFromUnion<
  ConverterEvent<TMIMEType>,
  'type',
  'deserialization.success' | 'deserialization.failure'
>

/**
 * @public
 */
export declare type EditorContext = {
  activeDecorators: Array<string>
  converters: Array<Converter>
  keyGenerator: () => string
  schema: EditorSchema
  selection: EditorSelection
  value: Array<PortableTextBlock>
}

/**
 * @public
 */
export declare type EditorSchema = PortableTextMemberSchemaTypes

/** @public */
export declare type EditorSelection = {
  anchor: EditorSelectionPoint
  focus: EditorSelectionPoint
  backward?: boolean
} | null

/** @public */
export declare type EditorSelectionPoint = {
  path: Path
  offset: number
}

/**
 * @public
 */
export declare type EditorSelector<TSelected> = (
  snapshot: EditorSnapshot,
) => TSelected

/**
 * @public
 */
export declare type EditorSnapshot = {
  context: EditorContext
}

/**
 * @public
 */
export declare const getActiveAnnotations: EditorSelector<
  Array<PortableTextObject>
>

/**
 * @public
 */
export declare const getActiveListItem: EditorSelector<
  PortableTextListBlock['listItem'] | undefined
>

/**
 * @public
 */
export declare const getActiveStyle: EditorSelector<
  PortableTextTextBlock['style']
>

/**
 * @public
 */
export declare const getAnchorBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getAnchorChild: EditorSelector<
  | {
      node: PortableTextObject | PortableTextSpan
      path: [KeyedSegment_2, 'children', KeyedSegment_2]
    }
  | undefined
>

/**
 * @public
 */
export declare const getAnchorSpan: EditorSelector<
  | {
      node: PortableTextSpan
      path: [KeyedSegment_2, 'children', KeyedSegment_2]
    }
  | undefined
>

/**
 * @public
 */
export declare const getAnchorTextBlock: EditorSelector<
  | {
      node: PortableTextTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
declare function getBlockEndPoint({
  node,
  path,
}: {
  node: PortableTextBlock
  path: [KeyedSegment]
}): EditorSelectionPoint

/**
 * @public
 */
export declare const getBlockOffsets: EditorSelector<
  | {
      start: utils.BlockOffset
      end: utils.BlockOffset
    }
  | undefined
>

/**
 * @public
 */
declare function getBlockStartPoint({
  node,
  path,
}: {
  node: PortableTextBlock
  path: [KeyedSegment]
}): EditorSelectionPoint

/**
 * @public
 */
export declare const getBlockTextBefore: EditorSelector<string>

/**
 * @public
 * Returns the selection of the of the word the caret is placed in.
 * Note: Only returns a word selection if the current selection is collapsed
 */
export declare const getCaretWordSelection: EditorSelector<EditorSelection>

/**
 * @public
 */
export declare const getFirstBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getFocusBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getFocusBlockObject: EditorSelector<
  | {
      node: PortableTextObject
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getFocusChild: EditorSelector<
  | {
      node: PortableTextObject | PortableTextSpan
      path: [KeyedSegment, 'children', KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getFocusListBlock: EditorSelector<
  | {
      node: PortableTextListBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getFocusSpan: EditorSelector<
  | {
      node: PortableTextSpan
      path: [KeyedSegment, 'children', KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getFocusTextBlock: EditorSelector<
  | {
      node: PortableTextTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getLastBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getNextBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getNextInlineObject: EditorSelector<
  | {
      node: PortableTextObject
      path: [KeyedSegment, 'children', KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getPreviousBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getPreviousInlineObject: EditorSelector<
  | {
      node: PortableTextObject
      path: [KeyedSegment, 'children', KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getSelectedBlocks: EditorSelector<
  Array<{
    node: PortableTextBlock
    path: [KeyedSegment]
  }>
>

/**
 * @public
 */
export declare const getSelectedSlice: EditorSelector<Array<PortableTextBlock>>

/**
 * @public
 */
export declare const getSelectedSpans: EditorSelector<
  Array<{
    node: PortableTextSpan
    path: [KeyedSegment, 'children', KeyedSegment]
  }>
>

/**
 * @public
 */
declare const getSelection_2: EditorSelector<EditorSelection>
export {getSelection_2 as getSelection}

/**
 * @public
 */
export declare const getSelectionEndBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getSelectionEndPoint: EditorSelector<
  EditorSelectionPoint | undefined
>

/**
 * @public
 */
export declare const getSelectionStartBlock: EditorSelector<
  | {
      node: PortableTextBlock
      path: [KeyedSegment]
    }
  | undefined
>

/**
 * @public
 */
export declare const getSelectionStartPoint: EditorSelector<
  EditorSelectionPoint | undefined
>

/**
 * @public
 */
export declare const getSelectionText: EditorSelector<string>

/**
 * @public
 */
declare function getTextBlockText(block: PortableTextTextBlock): string

/**
 * @public
 */
export declare const getTrimmedSelection: EditorSelector<EditorSelection>

/**
 * @public
 */
export declare const getValue: EditorSelector<Array<PortableTextBlock>>

/**
 * @public
 */
export declare function isActiveAnnotation(
  annotation: string,
): EditorSelector<boolean>

/**
 * @public
 */
export declare function isActiveDecorator(
  decorator: string,
): EditorSelector<boolean>

/**
 * @public
 */
export declare function isActiveListItem(
  listItem: string,
): EditorSelector<boolean>

/**
 * @public
 */
export declare function isActiveStyle(style: string): EditorSelector<boolean>

/**
 * @public
 */
export declare function isAtTheEndOfBlock(block: {
  node: PortableTextBlock
  path: [KeyedSegment]
}): EditorSelector<boolean>

/**
 * @public
 */
export declare function isAtTheStartOfBlock(block: {
  node: PortableTextBlock
  path: [KeyedSegment]
}): EditorSelector<boolean>

/**
 * @public
 */
declare function isEmptyTextBlock(block: PortableTextBlock): boolean

/**
 * @public
 */
declare function isEqualSelectionPoints(
  a: EditorSelectionPoint,
  b: EditorSelectionPoint,
): boolean

/**
 * @public
 */
declare function isKeyedSegment(segment: PathSegment): segment is KeyedSegment

/**
 * @public
 */
export declare function isOverlappingSelection(
  selection: EditorSelection,
): EditorSelector<boolean>

/**
 * @public
 */
export declare function isPointAfterSelection(
  point: EditorSelectionPoint,
): EditorSelector<boolean>

/**
 * @public
 */
export declare function isPointBeforeSelection(
  point: EditorSelectionPoint,
): EditorSelector<boolean>

/**
 * @public
 */
export declare const isSelectionCollapsed: EditorSelector<boolean>

/**
 * @public
 */
export declare const isSelectionExpanded: EditorSelector<boolean>

/**
 * @public
 */
declare function isSpan(
  context: Pick<EditorContext, 'schema'>,
  child: PortableTextChild,
): child is PortableTextSpan

/**
 * @public
 */
declare function isTextBlock(
  context: Pick<EditorContext, 'schema'>,
  block: PortableTextBlock,
): block is PortableTextTextBlock

/**
 * @beta
 */
declare function mergeTextBlocks({
  context,
  targetBlock,
  incomingBlock,
}: {
  context: Pick<EditorContext, 'keyGenerator' | 'schema'>
  targetBlock: PortableTextTextBlock
  incomingBlock: PortableTextTextBlock
}): PortableTextTextBlock<PortableTextSpan | PortableTextObject>

declare type MIMEType = `${string}/${string}`

/**
 * @internal
 */
declare type PickFromUnion<
  TUnion,
  TTagKey extends keyof TUnion,
  TPickedTags extends TUnion[TTagKey],
> = TUnion extends Record<TTagKey, TPickedTags> ? TUnion : never

/** @internal */
export declare type PortableTextMemberSchemaTypes = {
  annotations: (ObjectSchemaType & {
    i18nTitleKey?: string
  })[]
  block: ObjectSchemaType
  blockObjects: ObjectSchemaType[]
  decorators: BlockDecoratorDefinition[]
  inlineObjects: ObjectSchemaType[]
  portableText: ArraySchemaType<PortableTextBlock>
  span: ObjectSchemaType
  styles: BlockStyleDefinition[]
  lists: BlockListDefinition[]
}

/**
 * @public
 */
declare function reverseSelection(
  selection: NonNullable<EditorSelection>,
): NonNullable<EditorSelection>

declare type Serializer<TMIMEType extends MIMEType> = ({
  context,
  event,
}: {
  context: EditorContext
  event: PickFromUnion<ConverterEvent<TMIMEType>, 'type', 'serialize'>
}) => PickFromUnion<
  ConverterEvent<TMIMEType>,
  'type',
  'serialization.success' | 'serialization.failure'
>

/**
 * @public
 */
declare function sliceBlocks({
  blocks,
  selection,
}: {
  blocks: Array<PortableTextBlock>
  selection: EditorSelection
}): Array<PortableTextBlock>

/**
 * @public
 */
declare function spanSelectionPointToBlockOffset({
  value,
  selectionPoint,
}: {
  value: Array<PortableTextBlock>
  selectionPoint: EditorSelectionPoint
}): BlockOffset | undefined

/**
 * @beta
 */
declare function splitTextBlock({
  context,
  block,
  point,
}: {
  context: Pick<EditorContext, 'schema'>
  block: PortableTextTextBlock
  point: EditorSelectionPoint
}):
  | {
      before: PortableTextTextBlock
      after: PortableTextTextBlock
    }
  | undefined

declare namespace utils {
  export {
    BlockOffset,
    EditorSelection,
    EditorSelectionPoint,
    blockOffsetToSpanSelectionPoint,
    spanSelectionPointToBlockOffset,
    blockOffsetsToSelection,
    getBlockEndPoint,
    getBlockStartPoint,
    getTextBlockText,
    isEmptyTextBlock,
    isEqualSelectionPoints,
    isKeyedSegment,
    isSpan,
    isTextBlock,
    mergeTextBlocks,
    reverseSelection,
    sliceBlocks,
    splitTextBlock,
  }
}

export {}
