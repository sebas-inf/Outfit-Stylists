import { isPortableTextTextBlock, isPortableTextSpan, isKeySegment } from "@sanity/types";
import { getSelectedSpans } from "../_chunks-es/selector.is-active-style.js";
import { getActiveListItem, getActiveStyle, getTrimmedSelection, isActiveAnnotation, isActiveDecorator, isActiveListItem, isActiveStyle } from "../_chunks-es/selector.is-active-style.js";
import { getSelectedBlocks, getSelectionStartPoint, getSelectionEndPoint } from "../_chunks-es/selector.is-at-the-start-of-block.js";
import { getCaretWordSelection, getFirstBlock, getFocusBlock, getFocusBlockObject, getFocusChild, getFocusListBlock, getFocusSpan, getFocusTextBlock, getLastBlock, getNextBlock, getNextInlineObject, getPreviousBlock, getPreviousInlineObject, getSelectedSlice, getSelectionEndBlock, getSelectionStartBlock, getSelectionText, isAtTheEndOfBlock, isAtTheStartOfBlock, isSelectionCollapsed, isSelectionExpanded } from "../_chunks-es/selector.is-at-the-start-of-block.js";
import { isKeyedSegment, spanSelectionPointToBlockOffset } from "../_chunks-es/util.slice-blocks.js";
import { getBlockTextBefore } from "../_chunks-es/selector.get-text-before.js";
import { reverseSelection } from "../_chunks-es/util.reverse-selection.js";
const getActiveAnnotations = (snapshot) => {
  if (!snapshot.context.selection)
    return [];
  const selectedBlocks = getSelectedBlocks(snapshot), selectedSpans = getSelectedSpans(snapshot);
  return selectedSpans.length === 0 ? [] : selectedBlocks.flatMap((block) => isPortableTextTextBlock(block.node) ? block.node.markDefs ?? [] : []).filter((markDef) => selectedSpans.some((span) => span.node.marks?.includes(markDef._key)));
}, getAnchorBlock = ({
  context
}) => {
  const key = context.selection && isKeyedSegment(context.selection.anchor.path[0]) ? context.selection.anchor.path[0]._key : void 0, node = key ? context.value.find((block) => block._key === key) : void 0;
  return node && key ? {
    node,
    path: [{
      _key: key
    }]
  } : void 0;
}, getAnchorTextBlock = ({
  context
}) => {
  const anchorBlock = getAnchorBlock({
    context
  });
  return anchorBlock && isPortableTextTextBlock(anchorBlock.node) ? {
    node: anchorBlock.node,
    path: anchorBlock.path
  } : void 0;
}, getAnchorChild = ({
  context
}) => {
  const anchorBlock = getAnchorTextBlock({
    context
  });
  if (!anchorBlock)
    return;
  const key = context.selection && isKeyedSegment(context.selection.anchor.path[2]) ? context.selection.anchor.path[2]._key : void 0, node = key ? anchorBlock.node.children.find((span) => span._key === key) : void 0;
  return node && key ? {
    node,
    path: [...anchorBlock.path, "children", {
      _key: key
    }]
  } : void 0;
}, getAnchorSpan = ({
  context
}) => {
  const anchorChild = getAnchorChild({
    context
  });
  return anchorChild && isPortableTextSpan(anchorChild.node) ? {
    node: anchorChild.node,
    path: anchorChild.path
  } : void 0;
}, getBlockOffsets = ({
  context
}) => {
  if (!context.selection)
    return;
  const selectionStartPoint = getSelectionStartPoint({
    context
  }), selectionEndPoint = getSelectionEndPoint({
    context
  });
  if (!selectionStartPoint || !selectionEndPoint)
    return;
  const start = spanSelectionPointToBlockOffset({
    value: context.value,
    selectionPoint: selectionStartPoint
  }), end = spanSelectionPointToBlockOffset({
    value: context.value,
    selectionPoint: selectionEndPoint
  });
  return start && end ? {
    start,
    end
  } : void 0;
}, getSelection = ({
  context
}) => context.selection, getValue = ({
  context
}) => context.value;
function isPointAfterSelection(point) {
  return (snapshot) => {
    if (!snapshot.context.selection)
      return !1;
    const selection = reverseSelection(snapshot.context.selection), pointBlockKey = isKeySegment(point.path[0]) ? point.path[0]._key : void 0, pointChildKey = isKeySegment(point.path[2]) ? point.path[2]._key : void 0, endBlockKey = isKeySegment(selection.focus.path[0]) ? selection.focus.path[0]._key : void 0, endChildKey = isKeySegment(selection.focus.path[2]) ? selection.focus.path[2]._key : void 0;
    if (!pointBlockKey || !endBlockKey)
      return !1;
    let after = !1;
    for (const block of snapshot.context.value) {
      if (block._key === endBlockKey) {
        if (block._key !== pointBlockKey) {
          after = !0;
          break;
        }
        if (!isPortableTextTextBlock(block) || !pointChildKey || !endChildKey)
          break;
        for (const child of block.children) {
          if (child._key === endChildKey) {
            if (child._key !== pointChildKey) {
              after = !0;
              break;
            }
            after = point.offset > selection.focus.offset;
            break;
          }
          if (child._key === pointChildKey)
            break;
        }
      }
      if (block._key === pointBlockKey)
        break;
    }
    return after;
  };
}
function isPointBeforeSelection(point) {
  return (snapshot) => {
    if (!snapshot.context.selection)
      return !1;
    const selection = reverseSelection(snapshot.context.selection), pointBlockKey = isKeySegment(point.path[0]) ? point.path[0]._key : void 0, pointChildKey = isKeySegment(point.path[2]) ? point.path[2]._key : void 0, startBlockKey = isKeySegment(selection.anchor.path[0]) ? selection.anchor.path[0]._key : void 0, startChildKey = isKeySegment(selection.anchor.path[2]) ? selection.anchor.path[2]._key : void 0;
    if (!pointBlockKey || !startBlockKey)
      return !1;
    let before = !1;
    for (const block of snapshot.context.value) {
      if (block._key === pointBlockKey) {
        if (block._key !== startBlockKey) {
          before = !0;
          break;
        }
        if (!isPortableTextTextBlock(block) || !pointChildKey || !startChildKey)
          break;
        for (const child of block.children) {
          if (child._key === pointChildKey) {
            if (child._key !== startChildKey) {
              before = !0;
              break;
            }
            before = point.offset < selection.anchor.offset;
            break;
          }
          if (child._key === startChildKey)
            break;
        }
      }
      if (block._key === startBlockKey)
        break;
    }
    return before;
  };
}
function isOverlappingSelection(selection) {
  return ({
    context
  }) => {
    if (!selection || !context.selection)
      return !1;
    const selectionStartPoint = getSelectionStartPoint({
      context: {
        ...context,
        selection
      }
    }), selectionEndPoint = getSelectionEndPoint({
      context: {
        ...context,
        selection
      }
    });
    return !(!selectionStartPoint || !selectionEndPoint || !isPointAfterSelection(selectionStartPoint)({
      context
    }) || !isPointBeforeSelection(selectionEndPoint)({
      context
    }));
  };
}
export {
  getActiveAnnotations,
  getActiveListItem,
  getActiveStyle,
  getAnchorBlock,
  getAnchorChild,
  getAnchorSpan,
  getAnchorTextBlock,
  getBlockOffsets,
  getBlockTextBefore,
  getCaretWordSelection,
  getFirstBlock,
  getFocusBlock,
  getFocusBlockObject,
  getFocusChild,
  getFocusListBlock,
  getFocusSpan,
  getFocusTextBlock,
  getLastBlock,
  getNextBlock,
  getNextInlineObject,
  getPreviousBlock,
  getPreviousInlineObject,
  getSelectedBlocks,
  getSelectedSlice,
  getSelectedSpans,
  getSelection,
  getSelectionEndBlock,
  getSelectionEndPoint,
  getSelectionStartBlock,
  getSelectionStartPoint,
  getSelectionText,
  getTrimmedSelection,
  getValue,
  isActiveAnnotation,
  isActiveDecorator,
  isActiveListItem,
  isActiveStyle,
  isAtTheEndOfBlock,
  isAtTheStartOfBlock,
  isOverlappingSelection,
  isPointAfterSelection,
  isPointBeforeSelection,
  isSelectionCollapsed,
  isSelectionExpanded
};
//# sourceMappingURL=index.js.map
