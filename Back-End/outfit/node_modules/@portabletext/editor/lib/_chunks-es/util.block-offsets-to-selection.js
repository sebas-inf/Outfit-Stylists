import { isPortableTextTextBlock, isPortableTextSpan } from "@sanity/types";
import { blockOffsetToSpanSelectionPoint } from "./util.slice-blocks.js";
function isTypedObject(object) {
  return isRecord(object) && typeof object._type == "string";
}
function isRecord(value) {
  return !!value && (typeof value == "object" || typeof value == "function");
}
function parseBlock({
  context,
  block,
  options
}) {
  if (!isTypedObject(block) || block._type !== context.schema.block.name && !context.schema.blockObjects.some((blockObject) => blockObject.name === block._type))
    return;
  if (block._type !== context.schema.block.name) {
    const _key = options.refreshKeys ? context.keyGenerator() : typeof block._key == "string" ? block._key : context.keyGenerator();
    return {
      ...block,
      _key
    };
  }
  if (!isPortableTextTextBlock(block))
    return {
      _type: context.schema.block.name,
      _key: options.refreshKeys ? context.keyGenerator() : typeof block._key == "string" ? block._key : context.keyGenerator(),
      children: [{
        _key: context.keyGenerator(),
        _type: context.schema.span.name,
        text: "",
        marks: []
      }],
      markDefs: [],
      style: context.schema.styles[0].value
    };
  const markDefKeyMap = /* @__PURE__ */ new Map(), markDefs = (block.markDefs ?? []).flatMap((markDef) => {
    if (context.schema.annotations.some((annotation) => annotation.name === markDef._type)) {
      const _key = options.refreshKeys ? context.keyGenerator() : markDef._key;
      return markDefKeyMap.set(markDef._key, _key), [{
        ...markDef,
        _key
      }];
    }
    return [];
  }), children = block.children.flatMap((child) => {
    if (!isTypedObject(child))
      return [];
    if (child._type !== context.schema.span.name && !context.schema.inlineObjects.some((inlineObject) => inlineObject.name === child._type))
      return [];
    if (!isPortableTextSpan(child))
      return [{
        ...child,
        _key: options.refreshKeys ? context.keyGenerator() : child._key
      }];
    const marks = (child.marks ?? []).flatMap((mark) => markDefKeyMap.has(mark) ? [markDefKeyMap.get(mark)] : context.schema.decorators.some((decorator) => decorator.value === mark) ? [mark] : []);
    return [{
      ...child,
      _key: options.refreshKeys ? context.keyGenerator() : child._key,
      marks
    }];
  }), parsedBlock = {
    ...block,
    _key: options.refreshKeys ? context.keyGenerator() : block._key,
    children: children.length > 0 ? children : [{
      _key: context.keyGenerator(),
      _type: context.schema.span.name,
      text: "",
      marks: []
    }],
    markDefs
  };
  if (!context.schema.styles.find((style) => style.value === block.style)) {
    const defaultStyle = context.schema.styles[0].value;
    defaultStyle !== void 0 ? parsedBlock.style = defaultStyle : delete parsedBlock.style;
  }
  return context.schema.lists.find((list) => list.value === block.listItem) || (delete parsedBlock.listItem, delete parsedBlock.level), parsedBlock;
}
function blockOffsetsToSelection({
  value,
  offsets,
  backward
}) {
  const anchor = blockOffsetToSpanSelectionPoint({
    value,
    blockOffset: offsets.anchor,
    direction: backward ? "backward" : "forward"
  }), focus = blockOffsetToSpanSelectionPoint({
    value,
    blockOffset: offsets.focus,
    direction: backward ? "forward" : "backward"
  });
  return !anchor || !focus ? null : {
    anchor,
    focus,
    backward
  };
}
export {
  blockOffsetsToSelection,
  parseBlock
};
//# sourceMappingURL=util.block-offsets-to-selection.js.map
