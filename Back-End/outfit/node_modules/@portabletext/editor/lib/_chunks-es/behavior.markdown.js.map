{"version":3,"file":"behavior.markdown.js","sources":["../../src/behaviors/behavior.markdown.ts"],"sourcesContent":["import {isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSchema} from '../editor/define-schema'\nimport * as selectors from '../selectors'\nimport {getBlockTextBefore} from '../selectors/selector.get-text-before'\nimport {spanSelectionPointToBlockOffset} from '../utils/util.block-offset'\nimport {getTextBlockText} from '../utils/util.get-text-block-text'\nimport {defineBehavior} from './behavior.types'\n\n/**\n * @beta\n */\nexport type MarkdownBehaviorsConfig = {\n  horizontalRuleObject?: (context: {\n    schema: EditorSchema\n  }) => {name: string; value?: {[prop: string]: unknown}} | undefined\n  defaultStyle?: (context: {schema: EditorSchema}) => string | undefined\n  headingStyle?: (context: {\n    schema: EditorSchema\n    level: number\n  }) => string | undefined\n  blockquoteStyle?: (context: {schema: EditorSchema}) => string | undefined\n  unorderedListStyle?: (context: {schema: EditorSchema}) => string | undefined\n  orderedListStyle?: (context: {schema: EditorSchema}) => string | undefined\n}\n\n/**\n * @beta\n * Create markdown behaviors for common markdown actions such as converting ### to headings, --- to HRs, and more.\n *\n * @example\n * Configure the bundled markdown behaviors\n * ```ts\n * import {EditorProvider} from '@portabletext/editor'\n * import {createMarkdownBehaviors, coreBehaviors} from '@portabletext/editor/behaviors'\n *\n * function App() {\n *  return (\n *   <EditorProvider\n *    initialConfig={{\n *    behaviors: [\n *    ...coreBehaviors,\n *    ...createMarkdownBehaviors({\n *        horizontalRuleObject: ({schema}) => {\n *          const name = schema.blockObjects.find(\n *            (object) => object.name === 'break',\n *          )?.name\n *          return name ? {name} : undefined\n *        },\n *        defaultStyle: ({schema}) => schema.styles[0].value,\n *        headingStyle: ({schema, level}) =>\n *          schema.styles.find((style) => style.value === `h${level}`)\n *            ?.value,\n *        blockquoteStyle: ({schema}) =>\n *          schema.styles.find((style) => style.value === 'blockquote')\n *            ?.value,\n *        unorderedListStyle: ({schema}) =>\n *          schema.lists.find((list) => list.value === 'bullet')?.value,\n *        orderedListStyle: ({schema}) =>\n *          schema.lists.find((list) => list.value === 'number')?.value,\n *      }),\n *      ]\n *    }}\n *    >\n *    {...}\n *    </EditorProvider>\n *  )\n * }\n * ```\n *\n */\nexport function createMarkdownBehaviors(config: MarkdownBehaviorsConfig) {\n  const automaticBlockquoteOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const previousInlineObject = selectors.getPreviousInlineObject({context})\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (previousInlineObject || !blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const caretAtTheEndOfQuote = blockOffset.offset === 1\n      const looksLikeMarkdownQuote = /^>/.test(blockText)\n      const blockquoteStyle = config.blockquoteStyle?.(context)\n\n      if (\n        caretAtTheEndOfQuote &&\n        looksLikeMarkdownQuote &&\n        blockquoteStyle !== undefined\n      ) {\n        return {focusTextBlock, style: blockquoteStyle}\n      }\n\n      return false\n    },\n    actions: [\n      () => [\n        {\n          type: 'insert.text',\n          text: ' ',\n        },\n      ],\n      (_, {focusTextBlock, style}) => [\n        {\n          type: 'text block.unset',\n          props: ['listItem', 'level'],\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'text block.set',\n          style,\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: 2,\n          },\n        },\n      ],\n    ],\n  })\n  const automaticHr = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const hrCharacter =\n        event.text === '-'\n          ? '-'\n          : event.text === '*'\n            ? '*'\n            : event.text === '_'\n              ? '_'\n              : undefined\n\n      if (hrCharacter === undefined) {\n        return false\n      }\n\n      const hrObject = config.horizontalRuleObject?.(context)\n      const focusBlock = selectors.getFocusTextBlock({context})\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n\n      if (!hrObject || !focusBlock || !selectionCollapsed) {\n        return false\n      }\n\n      const previousInlineObject = selectors.getPreviousInlineObject({context})\n      const textBefore = getBlockTextBefore({context})\n      const hrBlockOffsets = {\n        anchor: {\n          path: focusBlock.path,\n          offset: 0,\n        },\n        focus: {\n          path: focusBlock.path,\n          offset: 3,\n        },\n      }\n\n      if (\n        !previousInlineObject &&\n        textBefore === `${hrCharacter}${hrCharacter}`\n      ) {\n        return {hrObject, focusBlock, hrCharacter, hrBlockOffsets}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {hrCharacter}) => [\n        {\n          type: 'insert.text',\n          text: hrCharacter,\n        },\n      ],\n      (_, {hrObject, hrBlockOffsets}) => [\n        {\n          type: 'insert.block object',\n          placement: 'before',\n          blockObject: hrObject,\n        },\n        {\n          type: 'delete.text',\n          ...hrBlockOffsets,\n        },\n      ],\n    ],\n  })\n  const automaticHrOnPaste = defineBehavior({\n    on: 'paste',\n    guard: ({context, event}) => {\n      const text = event.data.getData('text/plain')\n      const hrRegExp = /^(---)$|(___)$|(\\*\\*\\*)$/gm\n      const hrCharacters = text.match(hrRegExp)?.[0]\n      const hrObject = config.horizontalRuleObject?.(context)\n      const focusBlock = selectors.getFocusBlock({context})\n\n      if (!hrCharacters || !hrObject || !focusBlock) {\n        return false\n      }\n\n      return {hrCharacters, hrObject, focusBlock}\n    },\n    actions: [\n      (_, {hrCharacters}) => [\n        {\n          type: 'insert.text',\n          text: hrCharacters,\n        },\n      ],\n      (_, {hrObject, focusBlock}) =>\n        isPortableTextTextBlock(focusBlock.node)\n          ? [\n              {\n                type: 'insert.text block',\n                textBlock: {children: focusBlock.node.children},\n                placement: 'after',\n              },\n              {\n                type: 'insert.block object',\n                blockObject: hrObject,\n                placement: 'after',\n              },\n              {type: 'delete.block', blockPath: focusBlock.path},\n            ]\n          : [\n              {\n                type: 'insert.block object',\n                blockObject: hrObject,\n                placement: 'after',\n              },\n            ],\n    ],\n  })\n  const automaticHeadingOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (!blockOffset) {\n        return false\n      }\n\n      const previousInlineObject = selectors.getPreviousInlineObject({context})\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const markdownHeadingSearch = /^#+/.exec(blockText)\n      const level = markdownHeadingSearch\n        ? markdownHeadingSearch[0].length\n        : undefined\n      const caretAtTheEndOfHeading = blockOffset.offset === level\n\n      if (previousInlineObject || !caretAtTheEndOfHeading) {\n        return false\n      }\n\n      const style =\n        level !== undefined\n          ? config.headingStyle?.({schema: context.schema, level})\n          : undefined\n\n      if (level !== undefined && style !== undefined) {\n        return {\n          focusTextBlock,\n          style: style,\n          level,\n        }\n      }\n\n      return false\n    },\n    actions: [\n      ({event}) => [event],\n      (_, {focusTextBlock, style, level}) => [\n        {\n          type: 'text block.unset',\n          props: ['listItem', 'level'],\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'text block.set',\n          style,\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: level + 1,\n          },\n        },\n      ],\n    ],\n  })\n  const clearStyleOnBackspace = defineBehavior({\n    on: 'delete.backward',\n    guard: ({context}) => {\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const atTheBeginningOfBLock =\n        focusTextBlock.node.children[0]._key === focusSpan.node._key &&\n        context.selection?.focus.offset === 0\n\n      const defaultStyle = config.defaultStyle?.(context)\n\n      if (\n        atTheBeginningOfBLock &&\n        defaultStyle &&\n        focusTextBlock.node.style !== defaultStyle\n      ) {\n        return {defaultStyle, focusTextBlock}\n      }\n\n      return false\n    },\n    actions: [\n      (_, {defaultStyle, focusTextBlock}) => [\n        {\n          type: 'text block.set',\n          style: defaultStyle,\n          at: focusTextBlock.path,\n        },\n      ],\n    ],\n  })\n  const automaticListOnSpace = defineBehavior({\n    on: 'insert.text',\n    guard: ({context, event}) => {\n      const isSpace = event.text === ' '\n\n      if (!isSpace) {\n        return false\n      }\n\n      const selectionCollapsed = selectors.isSelectionCollapsed({context})\n      const focusTextBlock = selectors.getFocusTextBlock({context})\n      const focusSpan = selectors.getFocusSpan({context})\n\n      if (!selectionCollapsed || !focusTextBlock || !focusSpan) {\n        return false\n      }\n\n      const previousInlineObject = selectors.getPreviousInlineObject({context})\n      const blockOffset = spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: {\n          path: [\n            {_key: focusTextBlock.node._key},\n            'children',\n            {_key: focusSpan.node._key},\n          ],\n          offset: context.selection?.focus.offset ?? 0,\n        },\n      })\n\n      if (previousInlineObject || !blockOffset) {\n        return false\n      }\n\n      const blockText = getTextBlockText(focusTextBlock.node)\n      const defaultStyle = config.defaultStyle?.(context)\n      const looksLikeUnorderedList = /^(-|\\*)/.test(blockText)\n      const unorderedListStyle = config.unorderedListStyle?.(context)\n      const caretAtTheEndOfUnorderedList = blockOffset.offset === 1\n\n      if (\n        defaultStyle &&\n        caretAtTheEndOfUnorderedList &&\n        looksLikeUnorderedList &&\n        unorderedListStyle !== undefined\n      ) {\n        return {\n          focusTextBlock,\n          listItem: unorderedListStyle,\n          listItemLength: 1,\n          style: defaultStyle,\n        }\n      }\n\n      const looksLikeOrderedList = /^1\\./.test(blockText)\n      const orderedListStyle = config.orderedListStyle?.(context)\n      const caretAtTheEndOfOrderedList = blockOffset.offset === 2\n\n      if (\n        defaultStyle &&\n        caretAtTheEndOfOrderedList &&\n        looksLikeOrderedList &&\n        orderedListStyle !== undefined\n      ) {\n        return {\n          focusTextBlock,\n          listItem: orderedListStyle,\n          listItemLength: 2,\n          style: defaultStyle,\n        }\n      }\n\n      return false\n    },\n    actions: [\n      ({event}) => [event],\n      (_, {focusTextBlock, style, listItem, listItemLength}) => [\n        {\n          type: 'text block.set',\n          listItem,\n          level: 1,\n          style,\n          at: focusTextBlock.path,\n        },\n        {\n          type: 'delete.text',\n          anchor: {\n            path: focusTextBlock.path,\n            offset: 0,\n          },\n          focus: {\n            path: focusTextBlock.path,\n            offset: listItemLength + 1,\n          },\n        },\n      ],\n    ],\n  })\n\n  const markdownBehaviors = [\n    automaticBlockquoteOnSpace,\n    automaticHeadingOnSpace,\n    automaticHr,\n    automaticHrOnPaste,\n    clearStyleOnBackspace,\n    automaticListOnSpace,\n  ]\n\n  return markdownBehaviors\n}\n"],"names":["createMarkdownBehaviors","config","automaticBlockquoteOnSpace","defineBehavior","on","guard","context","event","text","selectionCollapsed","selectors","focusTextBlock","focusSpan","previousInlineObject","blockOffset","spanSelectionPointToBlockOffset","value","selectionPoint","path","_key","node","offset","selection","focus","blockText","getTextBlockText","caretAtTheEndOfQuote","looksLikeMarkdownQuote","test","blockquoteStyle","undefined","style","actions","type","_","props","at","anchor","automaticHr","hrCharacter","hrObject","horizontalRuleObject","focusBlock","textBefore","getBlockTextBefore","hrBlockOffsets","placement","blockObject","automaticHrOnPaste","data","getData","hrRegExp","hrCharacters","match","isPortableTextTextBlock","textBlock","children","blockPath","automaticHeadingOnSpace","markdownHeadingSearch","exec","level","length","caretAtTheEndOfHeading","headingStyle","schema","clearStyleOnBackspace","atTheBeginningOfBLock","defaultStyle","automaticListOnSpace","looksLikeUnorderedList","unorderedListStyle","caretAtTheEndOfUnorderedList","listItem","listItemLength","looksLikeOrderedList","orderedListStyle","caretAtTheEndOfOrderedList"],"mappings":"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"}