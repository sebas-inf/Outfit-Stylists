import { c } from "react-compiler-runtime";
import React, { useEffect } from "react";
import { useEditor } from "../_chunks-es/plugin.event-listener.js";
import { EventListenerPlugin } from "../_chunks-es/plugin.event-listener.js";
import { createMarkdownBehaviors } from "../_chunks-es/behavior.markdown.js";
import { useActorRef } from "@xstate/react";
import isEqual from "lodash/isEqual.js";
import { setup, fromCallback, assign } from "xstate";
import { getFocusTextBlock, getSelectionStartPoint, isSelectionExpanded, getSelectionEndPoint } from "../_chunks-es/selector.is-at-the-start-of-block.js";
import { spanSelectionPointToBlockOffset, blockOffsetToSpanSelectionPoint, getBlockStartPoint, getBlockEndPoint, isEqualSelectionPoints } from "../_chunks-es/util.slice-blocks.js";
import { getBlockTextBefore } from "../_chunks-es/selector.get-text-before.js";
import { defineBehavior, raise } from "../_chunks-es/behavior.core.js";
import { jsx } from "react/jsx-runtime";
import { isTextBlock, splitTextBlock, mergeTextBlocks } from "../utils/index.js";
function BehaviorPlugin(props) {
  const $ = c(4), editor = useEditor();
  let t0, t1;
  return $[0] !== editor || $[1] !== props.behaviors ? (t0 = () => {
    const unregisterBehaviors = props.behaviors.map((behavior) => editor.registerBehavior({
      behavior
    }));
    return () => {
      unregisterBehaviors.forEach(_temp);
    };
  }, t1 = [editor, props.behaviors], $[0] = editor, $[1] = props.behaviors, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), useEffect(t0, t1), null;
}
function _temp(unregister) {
  return unregister();
}
const EditorRefPlugin = React.forwardRef((_, ref) => {
  const $ = c(2), editor = useEditor(), portableTextEditorRef = React.useRef(editor);
  let t0, t1;
  return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => portableTextEditorRef.current, t1 = [], $[0] = t0, $[1] = t1) : (t0 = $[0], t1 = $[1]), React.useImperativeHandle(ref, t0, t1), null;
});
EditorRefPlugin.displayName = "EditorRefPlugin";
const asteriskPairRegex = "(?<!\\*)\\*(?!\\s)([^*\\n]+?)(?<!\\s)\\*(?!\\*)", underscorePairRegex = "(?<!_)_(?!\\s)([^_\\n]+?)(?<!\\s)_(?!_)", italicRegex = new RegExp(`(${asteriskPairRegex}|${underscorePairRegex})$`), doubleAsteriskPairRegex = "(?<!\\*)\\*\\*(?!\\s)([^*\\n]+?)(?<!\\s)\\*\\*(?!\\*)", doubleUnderscorePairRegex = "(?<!_)__(?!\\s)([^_\\n]+?)(?<!\\s)__(?!_)", boldRegex = new RegExp(`(${doubleAsteriskPairRegex}|${doubleUnderscorePairRegex})$`);
function getTextToItalic(text) {
  return text.match(italicRegex)?.at(0);
}
function getTextToBold(text) {
  return text.match(boldRegex)?.at(0);
}
function useMarkdownEmphasisBehaviors(props) {
  const $ = c(10), editor = useEditor();
  let t0;
  $[0] !== editor || $[1] !== props.config ? (t0 = props.config.boldDecorator?.({
    schema: editor.getSnapshot().context.schema
  }), $[0] = editor, $[1] = props.config, $[2] = t0) : t0 = $[2];
  let t1;
  $[3] !== editor || $[4] !== props.config ? (t1 = props.config.italicDecorator?.({
    schema: editor.getSnapshot().context.schema
  }), $[3] = editor, $[4] = props.config, $[5] = t1) : t1 = $[5];
  let t2;
  $[6] !== editor || $[7] !== t0 || $[8] !== t1 ? (t2 = {
    input: {
      editor,
      boldDecorator: t0,
      italicDecorator: t1
    }
  }, $[6] = editor, $[7] = t0, $[8] = t1, $[9] = t2) : t2 = $[9], useActorRef(emphasisMachine, t2);
}
const emphasisListener = ({
  sendBack,
  input
}) => input.editor.registerBehavior({
  behavior: defineBehavior({
    on: "insert.text",
    guard: ({
      context,
      event
    }) => {
      const boldDecorator = input.boldDecorator, italicDecorator = input.italicDecorator;
      if (boldDecorator === void 0 && italicDecorator === void 0 || event.text !== "*" && event.text !== "_")
        return !1;
      const focusTextBlock = getFocusTextBlock({
        context
      }), selectionStartPoint = getSelectionStartPoint({
        context
      }), selectionStartOffset = selectionStartPoint ? spanSelectionPointToBlockOffset({
        value: context.value,
        selectionPoint: selectionStartPoint
      }) : void 0;
      if (!focusTextBlock || !selectionStartOffset)
        return !1;
      const textBefore = getBlockTextBefore({
        context
      }), textToItalic = getTextToItalic(`${textBefore}${event.text}`);
      if (textToItalic !== void 0 && italicDecorator !== void 0) {
        const prefixOffsets = {
          anchor: {
            path: focusTextBlock.path,
            offset: textBefore.length - textToItalic.length + 1
          },
          focus: {
            path: focusTextBlock.path,
            offset: textBefore.length - textToItalic.length + 1 + 1
          }
        }, suffixOffsets = {
          anchor: {
            path: focusTextBlock.path,
            offset: selectionStartOffset.offset
          },
          focus: {
            path: focusTextBlock.path,
            offset: selectionStartOffset.offset + 1
          }
        }, anchor = blockOffsetToSpanSelectionPoint({
          value: context.value,
          blockOffset: prefixOffsets.focus,
          direction: "backward"
        }), focus = blockOffsetToSpanSelectionPoint({
          value: context.value,
          blockOffset: suffixOffsets.anchor,
          direction: "forward"
        });
        return !anchor || !focus ? !1 : {
          prefixOffsets,
          suffixOffsets,
          decorator: italicDecorator,
          selection: {
            anchor,
            focus
          }
        };
      }
      const textToBold = getTextToBold(`${textBefore}${event.text}`);
      if (textToBold !== void 0 && boldDecorator !== void 0) {
        const prefixOffsets = {
          anchor: {
            path: focusTextBlock.path,
            offset: textBefore.length - textToBold.length + 1
          },
          focus: {
            path: focusTextBlock.path,
            offset: textBefore.length - textToBold.length + 1 + 2
          }
        }, suffixOffsets = {
          anchor: {
            path: focusTextBlock.path,
            offset: selectionStartOffset.offset - 1
          },
          focus: {
            path: focusTextBlock.path,
            offset: selectionStartOffset.offset + 1
          }
        }, anchor = blockOffsetToSpanSelectionPoint({
          value: context.value,
          blockOffset: prefixOffsets.focus,
          direction: "backward"
        }), focus = blockOffsetToSpanSelectionPoint({
          value: context.value,
          blockOffset: suffixOffsets.anchor,
          direction: "forward"
        });
        return !anchor || !focus ? !1 : {
          prefixOffsets,
          suffixOffsets,
          decorator: boldDecorator,
          selection: {
            anchor,
            focus
          }
        };
      }
      return !1;
    },
    actions: [({
      event
    }) => [event], (_, {
      prefixOffsets,
      suffixOffsets,
      decorator,
      selection
    }) => [{
      type: "decorator.add",
      decorator,
      selection
    }, {
      type: "delete.text",
      ...suffixOffsets
    }, {
      type: "delete.text",
      ...prefixOffsets
    }, {
      type: "effect",
      effect: () => {
        sendBack({
          type: "emphasis.add",
          blockOffset: {
            ...suffixOffsets.anchor,
            offset: suffixOffsets.anchor.offset - (prefixOffsets.focus.offset - prefixOffsets.anchor.offset)
          }
        });
      }
    }]]
  })
}), selectionListenerCallback = ({
  sendBack,
  input
}) => input.editor.registerBehavior({
  behavior: defineBehavior({
    on: "select",
    guard: ({
      context,
      event
    }) => {
      if (!event.selection)
        return {
          blockOffsets: void 0
        };
      const anchor = spanSelectionPointToBlockOffset({
        value: context.value,
        selectionPoint: event.selection.anchor
      }), focus = spanSelectionPointToBlockOffset({
        value: context.value,
        selectionPoint: event.selection.focus
      });
      return !anchor || !focus ? {
        blockOffsets: void 0
      } : {
        blockOffsets: {
          anchor,
          focus
        }
      };
    },
    actions: [(_, {
      blockOffsets
    }) => [{
      type: "effect",
      effect: () => {
        sendBack({
          type: "selection",
          blockOffsets
        });
      }
    }]]
  })
}), deleteBackwardListenerCallback = ({
  sendBack,
  input
}) => input.editor.registerBehavior({
  behavior: defineBehavior({
    on: "delete.backward",
    actions: [() => [{
      type: "history.undo"
    }, {
      type: "effect",
      effect: () => {
        sendBack({
          type: "delete.backward"
        });
      }
    }]]
  })
}), emphasisMachine = setup({
  types: {
    context: {},
    input: {},
    events: {}
  },
  actors: {
    "emphasis listener": fromCallback(emphasisListener),
    "delete.backward listener": fromCallback(deleteBackwardListenerCallback),
    "selection listener": fromCallback(selectionListenerCallback)
  }
}).createMachine({
  id: "emphasis",
  context: ({
    input
  }) => ({
    boldDecorator: input.boldDecorator,
    italicDecorator: input.italicDecorator,
    editor: input.editor
  }),
  initial: "idle",
  states: {
    idle: {
      invoke: [{
        src: "emphasis listener",
        input: ({
          context
        }) => ({
          editor: context.editor,
          boldDecorator: context.boldDecorator,
          italicDecorator: context.italicDecorator
        })
      }],
      on: {
        "emphasis.add": {
          target: "emphasis added",
          actions: assign({
            offsetAfterEmphasis: ({
              event
            }) => event.blockOffset
          })
        }
      }
    },
    "emphasis added": {
      exit: [assign({
        offsetAfterEmphasis: void 0
      })],
      invoke: [{
        src: "selection listener",
        input: ({
          context
        }) => ({
          editor: context.editor
        })
      }, {
        src: "delete.backward listener",
        input: ({
          context
        }) => ({
          editor: context.editor
        })
      }],
      on: {
        selection: {
          target: "idle",
          guard: ({
            context,
            event
          }) => !isEqual({
            anchor: context.offsetAfterEmphasis,
            focus: context.offsetAfterEmphasis
          }, event.blockOffsets)
        },
        "delete.backward": {
          target: "idle"
        }
      }
    }
  }
});
function MarkdownPlugin(props) {
  const editor = useEditor();
  return useMarkdownEmphasisBehaviors({
    config: props.config
  }), useEffect(() => {
    const unregisterBehaviors = createMarkdownBehaviors(props.config).map((behavior) => editor.registerBehavior({
      behavior
    }));
    return () => {
      for (const unregisterBehavior of unregisterBehaviors)
        unregisterBehavior();
    };
  }, [editor, props.config]), null;
}
const oneLineBehaviors = [
  /**
   * Hitting Enter on an expanded selection should just delete that selection
   * without causing a line break.
   */
  defineBehavior({
    on: "insert.break",
    guard: ({
      context
    }) => context.selection && isSelectionExpanded({
      context
    }) ? {
      selection: context.selection
    } : !1,
    actions: [(_, {
      selection
    }) => [{
      type: "delete",
      selection
    }]]
  }),
  /**
   * All other cases of `insert.break` should be aborted.
   */
  defineBehavior({
    on: "insert.break",
    actions: [() => [{
      type: "noop"
    }]]
  }),
  /**
   * `insert.block` `before` or `after` is not allowed in a one-line editor.
   */
  defineBehavior({
    on: "insert.block",
    guard: ({
      event
    }) => event.placement === "before" || event.placement === "after",
    actions: [() => [{
      type: "noop"
    }]]
  }),
  /**
   * Other cases of `insert.block` are allowed.
   *
   * If a text block is inserted and the focus block is fully selected, then
   * the focus block can be replaced with the inserted block.
   */
  defineBehavior({
    on: "insert.block",
    guard: ({
      context,
      event
    }) => {
      const focusTextBlock = getFocusTextBlock({
        context
      }), selectionStartPoint = getSelectionStartPoint({
        context
      }), selectionEndPoint = getSelectionEndPoint({
        context
      });
      if (!focusTextBlock || !isTextBlock(context, event.block) || !selectionStartPoint || !selectionEndPoint)
        return !1;
      const blockStartPoint = getBlockStartPoint(focusTextBlock), blockEndPoint = getBlockEndPoint(focusTextBlock), newFocus = getBlockEndPoint({
        node: event.block,
        path: [{
          _key: event.block._key
        }]
      });
      return isEqualSelectionPoints(blockStartPoint, selectionStartPoint) && isEqualSelectionPoints(blockEndPoint, selectionEndPoint) ? {
        focusTextBlock,
        newFocus
      } : !1;
    },
    actions: [({
      event
    }, {
      focusTextBlock,
      newFocus
    }) => [{
      type: "delete.block",
      blockPath: focusTextBlock.path
    }, {
      type: "insert.block",
      block: event.block,
      placement: "auto"
    }, {
      type: "select",
      selection: {
        anchor: newFocus,
        focus: newFocus
      }
    }]]
  }),
  /**
   * An ordinary `insert.block` is acceptable if it's a text block. In that
   * case it will get merged into the existing text block.
   */
  defineBehavior({
    on: "insert.block",
    guard: ({
      context,
      event
    }) => {
      const focusTextBlock = getFocusTextBlock({
        context
      }), selectionStartPoint = getSelectionStartPoint({
        context
      }), selectionEndPoint = getSelectionEndPoint({
        context
      });
      if (!focusTextBlock || !isTextBlock(context, event.block) || !selectionStartPoint || !selectionEndPoint)
        return !1;
      const blockBeforeStartPoint = splitTextBlock({
        context,
        block: focusTextBlock.node,
        point: selectionStartPoint
      })?.before, blockAfterEndPoint = splitTextBlock({
        context,
        block: focusTextBlock.node,
        point: selectionEndPoint
      })?.after;
      if (!blockBeforeStartPoint || !blockAfterEndPoint)
        return !1;
      const targetBlock = mergeTextBlocks({
        context,
        targetBlock: blockBeforeStartPoint,
        incomingBlock: event.block
      }), newFocus = getBlockEndPoint({
        node: targetBlock,
        path: [{
          _key: targetBlock._key
        }]
      }), mergedBlock = mergeTextBlocks({
        context,
        targetBlock,
        incomingBlock: blockAfterEndPoint
      });
      return {
        focusTextBlock,
        mergedBlock,
        newFocus
      };
    },
    actions: [(_, {
      focusTextBlock,
      mergedBlock,
      newFocus
    }) => [{
      type: "delete.block",
      blockPath: focusTextBlock.path
    }, {
      type: "insert.block",
      block: mergedBlock,
      placement: "auto"
    }, {
      type: "select",
      selection: {
        anchor: newFocus,
        focus: newFocus
      }
    }]]
  }),
  /**
   * Fallback Behavior to avoid `insert.block` in case the Behaviors above all
   * end up with a falsy guard.
   */
  defineBehavior({
    on: "insert.block",
    actions: [() => [{
      type: "noop"
    }]]
  }),
  /**
   * If multiple blocks are inserted, then the non-text blocks are filtered out
   * and the text blocks are merged into one block
   */
  defineBehavior({
    on: "insert.blocks",
    guard: ({
      context,
      event
    }) => event.blocks.filter((block) => isTextBlock(context, block)).reduce((targetBlock, incomingBlock) => mergeTextBlocks({
      context,
      targetBlock,
      incomingBlock
    })),
    actions: [
      // `insert.block` is raised so the Behavior above can handle the
      // insertion
      (_, block) => [raise({
        type: "insert.block",
        block,
        placement: "auto"
      })]
    ]
  }),
  /**
   * Block objects do not fit in a one-line editor
   */
  defineBehavior({
    on: "insert.block object",
    actions: [() => [{
      type: "noop"
    }]]
  }),
  /**
   * `insert.text block` is raised as an `insert.block` so it can be handled
   * by the Behaviors above.
   */
  defineBehavior({
    on: "insert.text block",
    actions: [({
      context,
      event
    }) => [raise({
      type: "insert.block",
      block: {
        _key: context.keyGenerator(),
        _type: context.schema.block.name,
        children: event.textBlock?.children ?? []
      },
      placement: event.placement
    })]]
  })
];
function OneLinePlugin() {
  const $ = c(1);
  let t0;
  return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ jsx(BehaviorPlugin, { behaviors: oneLineBehaviors }), $[0] = t0) : t0 = $[0], t0;
}
export {
  BehaviorPlugin,
  EditorRefPlugin,
  EventListenerPlugin,
  MarkdownPlugin,
  OneLinePlugin
};
//# sourceMappingURL=index.js.map
