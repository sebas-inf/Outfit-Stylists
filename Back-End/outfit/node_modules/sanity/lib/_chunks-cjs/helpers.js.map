{"version":3,"file":"helpers.js","sources":["../../src/_internal/cli/actions/deploy/helpers.ts"],"sourcesContent":["import fs from 'node:fs/promises'\nimport path from 'node:path'\nimport {PassThrough} from 'node:stream'\nimport {type Gzip} from 'node:zlib'\n\nimport {type CliCommandContext, type CliOutputter} from '@sanity/cli'\nimport {type SanityClient} from '@sanity/client'\nimport FormData from 'form-data'\nimport readPkgUp from 'read-pkg-up'\n\nimport {debug as debugIt} from '../../debug'\n\nexport const debug = debugIt.extend('deploy')\n\n// TODO: replace with `Promise.withResolvers()` once it lands in node\nfunction promiseWithResolvers<T>() {\n  let resolve!: (t: T) => void\n  let reject!: (err: unknown) => void\n  const promise = new Promise<T>((res, rej) => {\n    resolve = res\n    reject = rej\n  })\n  return {promise, resolve, reject}\n}\n\nexport interface ActiveDeployment {\n  deployedAt: string\n  deployedBy: string\n  isActiveDeployment: boolean\n  isAutoUpdating: boolean | null\n  size: string | null\n  createdAt: string\n  updatedAt: string\n  version: string\n}\n\nexport interface UserApplication {\n  id: string\n  projectId: string\n  title: string | null\n  appHost: string\n  urlType: 'internal' | 'external'\n  createdAt: string\n  updatedAt: string\n  type: 'studio'\n  activeDeployment?: ActiveDeployment | null\n}\n\nexport interface GetUserApplicationsOptions {\n  client: SanityClient\n}\n\nexport interface GetUserApplicationOptions extends GetUserApplicationsOptions {\n  appHost?: string\n}\n\nexport async function getUserApplication({\n  client,\n  appHost,\n}: GetUserApplicationOptions): Promise<UserApplication | null> {\n  try {\n    return await client.request({\n      uri: '/user-applications',\n      query: appHost ? {appHost} : {default: 'true'},\n    })\n  } catch (e) {\n    if (e?.statusCode === 404) {\n      return null\n    }\n\n    debug('Error getting user application', e)\n    throw e\n  }\n}\n\nexport async function getUserApplications({\n  client,\n}: GetUserApplicationsOptions): Promise<UserApplication[] | null> {\n  try {\n    return await client.request({\n      uri: '/user-applications',\n    })\n  } catch (e) {\n    if (e?.statusCode === 404) {\n      return null\n    }\n\n    debug('Error getting user application', e)\n    throw e\n  }\n}\n\nfunction createUserApplication(\n  client: SanityClient,\n  body: Pick<UserApplication, 'appHost' | 'urlType'> & {\n    title?: string\n  },\n): Promise<UserApplication> {\n  return client.request({uri: '/user-applications', method: 'POST', body})\n}\n\nexport interface GetOrCreateUserApplicationOptions {\n  client: SanityClient\n  context: Pick<CliCommandContext, 'output' | 'prompt'>\n  spinner: ReturnType<CliOutputter['spinner']>\n}\n\n/**\n * This function handles the logic for managing user applications when\n * studioHost is not provided in the CLI config.\n *\n * @internal\n *\n *    +-------------------------------+\n *    |   Fetch Existing user-app?   |\n *    +---------+--------------------+\n *              |\n *        +-----+-----+\n *        |           |\n *        v           v\n *   +---------+  +-------------------------+\n *   | Return  |  | Fetch all user apps     |\n *   | user-app|  +-------------------------+\n *   +---------+            |\n *                          v\n *           +---------------------------+\n *           |  User apps found?         |\n *           +-----------+---------------+\n *                       |\n *                +------v------+\n *                |             |\n *                v             v\n *   +--------------------+  +------------------------+\n *   | Show list and      |  | Prompt for hostname    |\n *   | prompt selection   |  | and create new app     |\n *   +--------------------+  +------------------------+\n */\nexport async function getOrCreateUserApplication({\n  client,\n  spinner,\n  context,\n}: GetOrCreateUserApplicationOptions): Promise<UserApplication> {\n  const {output, prompt} = context\n  // if there is already an existing user-app, then just return it\n  const existingUserApplication = await getUserApplication({client})\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  if (existingUserApplication) {\n    return existingUserApplication\n  }\n\n  const userApplications = await getUserApplications({client})\n\n  if (userApplications?.length) {\n    const choices = userApplications.map((app) => ({\n      value: app.appHost,\n      name: app.appHost,\n    }))\n\n    const selected = await prompt.single({\n      message: 'Select existing studio hostname',\n      type: 'list',\n      choices: [\n        {value: 'new', name: 'Create new studio hostname'},\n        new prompt.Separator(),\n        ...choices,\n      ],\n    })\n\n    // if the user selected an existing app, return it\n    if (selected !== 'new') {\n      return userApplications.find((app) => app.appHost === selected)!\n    }\n  }\n\n  // otherwise, prompt the user for a hostname\n  output.print('Your project has not been assigned a studio hostname.')\n  output.print('To deploy your Sanity Studio to our hosted sanity.studio service,')\n  output.print('you will need one. Please enter the part you want to use.')\n\n  const {promise, resolve} = promiseWithResolvers<UserApplication>()\n\n  await prompt.single({\n    type: 'input',\n    filter: (inp: string) => inp.replace(/\\.sanity\\.studio$/i, ''),\n    message: 'Studio hostname (<value>.sanity.studio):',\n    // if a string is returned here, it is relayed to the user and prompt allows\n    // the user to try again until this function returns true\n    validate: async (appHost: string) => {\n      try {\n        const response = await createUserApplication(client, {\n          appHost,\n          urlType: 'internal',\n        })\n        resolve(response)\n        return true\n      } catch (e) {\n        // if the name is taken, it should return a 409 so we relay to the user\n        if ([402, 409].includes(e?.statusCode)) {\n          return e?.response?.body?.message || 'Bad request' // just in case\n        }\n\n        debug('Error creating user application', e)\n        // otherwise, it's a fatal error\n        throw e\n      }\n    },\n  })\n\n  return await promise\n}\n\n/**\n * This function handles the logic for managing user applications when\n * studioHost is provided in the CLI config.\n *\n * @internal\n */\nexport async function getOrCreateUserApplicationFromConfig({\n  client,\n  context,\n  spinner,\n  appHost,\n}: GetOrCreateUserApplicationOptions & {\n  appHost: string\n}): Promise<UserApplication> {\n  const {output} = context\n  // if there is already an existing user-app, then just return it\n  const existingUserApplication = await getUserApplication({client, appHost})\n\n  // Complete the spinner so prompt can properly work\n  spinner.succeed()\n\n  if (existingUserApplication) {\n    return existingUserApplication\n  }\n\n  output.print('Your project has not been assigned a studio hostname.')\n  output.print(`Creating https://${appHost}.sanity.studio`)\n  output.print('')\n  spinner.start('Creating studio hostname')\n\n  try {\n    const response = await createUserApplication(client, {\n      appHost,\n      urlType: 'internal',\n    })\n    spinner.succeed()\n\n    return response\n  } catch (e) {\n    spinner.fail()\n    // if the name is taken, it should return a 409 so we relay to the user\n    if ([402, 409].includes(e?.statusCode)) {\n      throw new Error(e?.response?.body?.message || 'Bad request') // just in case\n    }\n\n    debug('Error creating user application from config', e)\n    // otherwise, it's a fatal error\n    throw e\n  }\n}\n\nexport interface CreateDeploymentOptions {\n  client: SanityClient\n  applicationId: string\n  version: string\n  isAutoUpdating: boolean\n  tarball: Gzip\n}\n\nexport async function createDeployment({\n  client,\n  tarball,\n  applicationId,\n  isAutoUpdating,\n  version,\n}: CreateDeploymentOptions): Promise<{location: string}> {\n  const formData = new FormData()\n  formData.append('isAutoUpdating', isAutoUpdating.toString())\n  formData.append('version', version)\n  formData.append('tarball', tarball, {contentType: 'application/gzip', filename: 'app.tar.gz'})\n\n  return client.request({\n    uri: `/user-applications/${applicationId}/deployments`,\n    method: 'POST',\n    headers: formData.getHeaders(),\n    body: formData.pipe(new PassThrough()),\n  })\n}\n\nexport interface DeleteUserApplicationOptions {\n  client: SanityClient\n  applicationId: string\n}\n\nexport async function deleteUserApplication({\n  applicationId,\n  client,\n}: DeleteUserApplicationOptions): Promise<void> {\n  await client.request({uri: `/user-applications/${applicationId}`, method: 'DELETE'})\n}\n\nexport async function getInstalledSanityVersion(): Promise<string> {\n  const sanityPkgPath = (await readPkgUp({cwd: __dirname}))?.path\n  if (!sanityPkgPath) {\n    throw new Error('Unable to resolve `sanity` module root')\n  }\n\n  const pkg = JSON.parse(await fs.readFile(sanityPkgPath, 'utf-8'))\n  if (typeof pkg?.version !== 'string') {\n    throw new Error('Unable to find version of `sanity` module')\n  }\n  return pkg.version\n}\n\nexport async function dirIsEmptyOrNonExistent(sourceDir: string): Promise<boolean> {\n  try {\n    const stats = await fs.stat(sourceDir)\n    if (!stats.isDirectory()) {\n      throw new Error(`Directory ${sourceDir} is not a directory`)\n    }\n  } catch (err) {\n    if (err.code === 'ENOENT') {\n      return true\n    }\n\n    throw err\n  }\n\n  const content = await fs.readdir(sourceDir)\n  return content.length === 0\n}\n\nexport async function checkDir(sourceDir: string): Promise<void> {\n  try {\n    const stats = await fs.stat(sourceDir)\n    if (!stats.isDirectory()) {\n      throw new Error(`Directory ${sourceDir} is not a directory`)\n    }\n  } catch (err) {\n    const error = err.code === 'ENOENT' ? new Error(`Directory \"${sourceDir}\" does not exist`) : err\n\n    throw error\n  }\n\n  try {\n    await fs.stat(path.join(sourceDir, 'index.html'))\n  } catch (err) {\n    const error =\n      err.code === 'ENOENT'\n        ? new Error(\n            [\n              `\"${sourceDir}/index.html\" does not exist -`,\n              '[SOURCE_DIR] must be a directory containing',\n              'a Sanity studio built using \"sanity build\"',\n            ].join(' '),\n          )\n        : err\n\n    throw error\n  }\n}\n"],"names":["debug","debugIt","extend","promiseWithResolvers","resolve","reject","promise","Promise","res","rej","getUserApplication","client","appHost","request","uri","query","default","e","statusCode","getUserApplications","createUserApplication","body","method","getOrCreateUserApplication","spinner","context","output","prompt","existingUserApplication","succeed","userApplications","length","choices","map","app","value","name","selected","single","message","type","Separator","find","print","filter","inp","replace","validate","response","urlType","includes","getOrCreateUserApplicationFromConfig","start","fail","Error","createDeployment","tarball","applicationId","isAutoUpdating","version","formData","FormData","append","toString","contentType","filename","headers","getHeaders","pipe","PassThrough","deleteUserApplication","getInstalledSanityVersion","sanityPkgPath","readPkgUp","cwd","__dirname","path","pkg","JSON","parse","fs","readFile","dirIsEmptyOrNonExistent","sourceDir","stat","isDirectory","err","code","readdir","checkDir","join"],"mappings":"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"}